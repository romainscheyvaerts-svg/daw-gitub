
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Nova DAW - Sauvegarde du Projet</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            background-color: #0c0d10;
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }
        button {
            background-color: #00f2ff;
            color: #000;
            border: none;
            padding: 20px 40px;
            font-size: 16px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.3);
            transition: all 0.2s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0, 242, 255, 0.5);
        }
        button:active {
            transform: scale(0.95);
        }
        .status {
            margin-top: 20px;
            font-family: monospace;
            color: #64748b;
        }
    </style>
</head>
<body>

    <button id="downloadBtn" onclick="downloadProject()">TÉLÉCHARGER LE PROJET (.zip)</button>
    <div id="status" class="status">Prêt pour l'archivage</div>

    <script>
        const projectFiles = [
{ path: "index.tsx", content: `
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);` },
{ path: "metadata.json", content: `
{
  "name": "Nova DAW - Pro Audio Workstation",
  "description": "A professional-grade Digital Audio Workstation simulation featuring real-time Web Audio DSP, multi-track arrangement, a full console mixer, and AI-assisted production tools.",
  "requestFramePermissions": [
    "microphone"
  ]
}` },
{ path: "index.html", content: `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#0c0d10">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Nova DAW | Pro Workstation</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-main: #0c0d10;
      --bg-surface: #14161a;
      --accent-neon: #00f2ff;
      --text-main: #e2e8f0;
      --safe-area-bottom: env(safe-area-inset-bottom);
      
      /* Standard Desktop Sizes */
      --btn-height: 2.5rem; /* 40px */
      --track-header-width: 16rem; /* 256px */
      --fader-width: 2.5rem;
    }

    /* --- MODE TABLETTE --- */
    body[data-view-mode="TABLET"] {
      --btn-height: 3.5rem; /* 56px pour le tactile */
      --track-header-width: 14rem;
      font-size: 110%; /* Légèrement plus gros */
    }
    
    /* Cacher le texte des boutons secondaires en mode tablette pour gagner de la place */
    body[data-view-mode="TABLET"] .hide-on-tablet-text span {
        display: none;
    }

    /* --- MODE MOBILE --- */
    body[data-view-mode="MOBILE"] {
      --btn-height: 3rem;
      --track-header-width: 100%; /* Prend toute la largeur si visible */
    }

    html, body {
      height: 100vh;
      height: 100dvh; /* Dynamic Viewport Height for Mobile */
      width: 100vw;
      margin: 0;
      padding: 0;
      background-color: var(--bg-main);
      color: var(--text-main);
      font-family: 'Inter', sans-serif;
      overflow: hidden;
      user-select: none;
      -webkit-font-smoothing: antialiased;
      
      /* MOBILE GESTURE LOCK */
      overscroll-behavior: none; /* Disable pull-to-refresh */
      touch-action: none; /* Disable browser pinch/pan, we handle it manually */
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
    }

    #root {
      height: 100%;
      width: 100%;
      display: flex;
      flex-direction: column;
    }

    .mono { font-family: 'JetBrains Mono', monospace; }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 4px; height: 4px; }
    ::-webkit-scrollbar-track { background: var(--bg-main); }
    ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.1); border-radius: 10px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-neon); }

    .fx-slot { transition: all 0.1s ease; cursor: grab; }
    .delete-fx {
      position: absolute; top: -4px; right: -4px; width: 14px; height: 14px;
      background: #ef4444; color: white; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 8px; opacity: 0; transition: all 0.2s ease; z-index: 50;
    }
    .fx-slot:hover .delete-fx { opacity: 1; }

    /* Gestion Scrollbars selon le mode */
    body[data-view-mode="MOBILE"] ::-webkit-scrollbar { 
        width: 0px; 
        background: transparent; 
    }
    
    body[data-view-mode="TABLET"] ::-webkit-scrollbar {
        width: 0px;
    }

    input[type="range"] { appearance: none; background: rgba(255, 255, 255, 0.05); border-radius: 10px; height: 3px; }
    input[type="range"]::-webkit-slider-thumb { appearance: none; width: 10px; height: 10px; background: var(--accent-neon); border-radius: 50%; cursor: pointer; }
    
    /* Agrandir les sliders en mode tactile */
    body[data-view-mode="TABLET"] input[type="range"]::-webkit-slider-thumb,
    body[data-view-mode="MOBILE"] input[type="range"]::-webkit-slider-thumb {
        width: 20px;
        height: 20px;
    }
    
    /* Utilitaires Tactiles */
    .touch-manipulation { touch-action: manipulation; }
    .touch-none { touch-action: none; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "react/": "https://esm.sh/react@^19.2.3/",
      "react": "https://esm.sh/react@^19.2.3",
      "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
      "@google/genai": "https://esm.sh/@google/genai@^1.34.0"
    }
  }
  <\/script>
</head>
<body>
  <div id="root"></div>
</body>
</html>` },
{ path: "types.ts", content: `
import React from 'react';

export enum TrackType {
  AUDIO = 'AUDIO',
  MIDI = 'MIDI',
  BUS = 'BUS',
  SEND = 'SEND'
}

export type ViewType = 'ARRANGEMENT' | 'MIXER';
export type MobileTab = 'PROJECT' | 'MIXER' | 'NOVA' | 'BROWSER'; 
export type EditorTool = 'SELECT' | 'SPLIT' | 'ERASE' | 'AUTOMATION';
export type ViewMode = 'DESKTOP' | 'TABLET' | 'MOBILE'; // NOUVEAU TYPE

export enum ProjectPhase {
  SETUP = 'SETUP',
  RECORDING = 'RECORDING',
  MIXING = 'MIXING',
  MASTERING = 'MASTERING'
}

export enum GuideStep {
  WELCOME = 'WELCOME',
  IMPORT_INSTRUMENTAL = 'IMPORT_INSTRUMENTAL',
  PREPARE_VOCAL = 'PREPARE_VOCAL',
  RECORDING = 'RECORDING',
  REVIEW = 'REVIEW',
  EXPORT = 'EXPORT'
}

export type PluginType = 'REVERB' | 'DELAY' | 'CHORUS' | 'FLANGER' | 'DOUBLER' | 'STEREOSPREADER' | 'COMPRESSOR' | 'AUTOTUNE' | 'DEESSER' | 'DENOISER' | 'PROEQ12' | 'VOCALSATURATOR' | 'MASTERSYNC';

export interface PluginMetadata {
  id: string;
  name: string;
  type: PluginType;
  format: 'VST3' | 'AU' | 'VST' | 'INTERNAL';
  vendor: string;
  version: string;
  latency: number; 
  localPath?: string;
}

export interface PluginInstance {
  id: string;
  name: string;
  type: PluginType;
  isEnabled: boolean;
  params: Record<string, any>;
  latency: number; 
}

export interface TrackSend {
  id: string;          
  level: number;       
  isEnabled: boolean;
}

export interface Clip {
  id: string;
  start: number;
  duration: number;
  offset: number; 
  fadeIn: number; 
  fadeOut: number; 
  name: string;
  color: string;
  type: TrackType;
  buffer?: AudioBuffer;
  isMuted?: boolean;
  gain?: number;
}

export interface AutomationPoint {
  id: string;
  time: number;
  value: number;
}

export interface AutomationLane {
  id: string;
  parameterName: 'volume' | 'pan' | string;
  points: AutomationPoint[];
  color: string;
  isExpanded: boolean;
  min: number;
  max: number;
}

export interface Track {
  id: string;
  name: string;
  type: TrackType;
  color: string;
  isMuted: boolean;
  isSolo: boolean;
  isTrackArmed: boolean;
  isFrozen: boolean;
  volume: number;
  pan: number;
  outputTrackId: string; 
  sends: TrackSend[];
  clips: Clip[];
  plugins: PluginInstance[];
  automationLanes: AutomationLane[];
  totalLatency: number;
}

export interface DAWState {
  id: string;
  name: string;
  bpm: number;
  isPlaying: boolean;
  isRecording: boolean;
  currentTime: number;
  isLoopActive: boolean;
  loopStart: number;
  loopEnd: number;
  tracks: Track[];
  selectedTrackId: string | null;
  currentView: ViewType;
  projectPhase: ProjectPhase;
  isLowLatencyMode: boolean; 
  isRecModeActive: boolean;
  systemMaxLatency: number; 
}

export interface ContextMenuItem {
  label: string;
  onClick: () => void;
  icon?: string;
  danger?: boolean;
  component?: React.ReactNode;
}

// --- AI & Chat System Types ---
export type AIChatRole = 'user' | 'assistant' | 'system';

export interface AIChatMessage {
  id: string;
  role: AIChatRole;
  content: string;
  timestamp: number;
  isCommand?: boolean;
  executedAction?: string;
}

export type AIActionType = 
  | 'UPDATE_PLUGIN' 
  | 'UPDATE_TRACK' 
  | 'ADD_TRACK'
  | 'CREATE_TRACK' 
  | 'DELETE_TRACK' 
  | 'SET_VOLUME'
  | 'SET_PAN'
  | 'MUTE_TRACK'
  | 'SOLO_TRACK'
  | 'RENAME_TRACK'
  | 'OPEN_PLUGIN'
  | 'CLOSE_PLUGIN'
  | 'SET_PLUGIN_PARAM'
  | 'BYPASS_PLUGIN'
  | 'SET_SEND_LEVEL'
  | 'PREPARE_REC' 
  | 'CLEAN_MIX'
  | 'RESET_FX'
  | 'NORMALIZE_CLIP'
  | 'SPLIT_CLIP'
  | 'MUTE_CLIP'
  | 'PLAY'
  | 'STOP'
  | 'RECORD'
  | 'SEEK'
  | 'SET_LOOP'
  | 'SET_BPM'
  | 'SET_AUTOMATION'
  | 'RUN_MASTER_SYNC'
  | 'ANALYZE_INSTRU'
  | 'DUPLICATE_TRACK'
  | 'REMOVE_SILENCE'; // Added

export interface AIAction {
  action: AIActionType;
  payload: any;
  description?: string;
}

declare global {
  interface Window {
    DAW_CONTROL: {
      // Logic & Transport
      play: () => void;
      stop: () => void;
      record: () => void;
      seek: (time: number) => void;
      setBpm: (bpm: number) => void;
      setLoop: (start: number, end: number, active?: boolean) => void;
      
      // Tracks Management
      setVolume: (trackId: string, volume: number) => void;
      setPan: (trackId: string, pan: number) => void;
      muteTrack: (trackId: string, isMuted: boolean) => void;
      soloTrack: (trackId: string, isSolo: boolean) => void;
      renameTrack: (trackId: string, newName: string) => void;
      duplicateTrack: (trackId: string) => void;
      addTrack: (type: TrackType, name?: string) => void;
      deleteTrack: (trackId: string) => void;

      // Plugins & FX
      openPlugin: (trackId: string, pluginType: PluginType) => void;
      closePlugin: () => void;
      setPluginParam: (trackId: string, pluginId: string, paramName: string, value: any) => void;
      bypassPlugin: (trackId: string, pluginId: string, isEnabled: boolean) => void;
      setSendLevel: (trackId: string, sendId: string, level: number) => void;
      
      // Advanced Actions
      runMasterSync: () => void;
      normalizeClip: (trackId: string, clipId: string) => void;
      splitClip: (trackId: string, clipId: string, time: number) => void;
      syncAutoTuneScale: (rootKey: number, scale: string) => void;
      removeSilence: (trackId: string) => void; // Added
      
      // Data Access
      getInstrumentalBuffer: () => AudioBuffer | null;
      getState: () => DAWState;
    };
  }
}
` },
{ path: "engine/AudioEngine.ts", content: `
import { Track, Clip, PluginInstance, TrackType, TrackSend, AutomationLane } from '../types';
import { ReverbNode } from '../plugins/ReverbPlugin';
import { SyncDelayNode } from '../plugins/DelayPlugin';
import { ChorusNode } from '../plugins/ChorusPlugin';
import { FlangerNode } from '../plugins/FlangerPlugin';
import { VocalDoublerNode } from '../plugins/DoublerPlugin';
import { StereoSpreaderNode } from '../plugins/StereoSpreaderPlugin';
import { AutoTuneNode } from '../plugins/AutoTunePlugin';
import { CompressorNode } from '../plugins/CompressorPlugin';
import { DeEsserNode } from '../plugins/DeEsserPlugin';
import { DenoiserNode } from '../plugins/DenoiserPlugin';
import { ProEQ12Node } from '../plugins/ProEQ12Plugin';
import { VocalSaturatorNode } from '../plugins/VocalSaturatorPlugin';
import { MasterSyncNode } from '../plugins/MasterSyncPlugin';

interface TrackDSP {
  input: GainNode;          
  output: GainNode;         
  panner: StereoPannerNode; 
  gain: GainNode;           
  analyzer: AnalyserNode;   
  pluginChain: Map<string, { input: AudioNode; output: AudioNode; instance: any }>; 
  sends: Map<string, GainNode>; 
}

interface ScheduledSource {
  source: AudioBufferSourceNode;
  gain: GainNode;
  clipId: string;
}

export class AudioEngine {
  public ctx: AudioContext | null = null;
  private masterOutput: GainNode | null = null;
  private masterAnalyzer: AnalyserNode | null = null;
  
  // Graph Audio
  private tracksDSP: Map<string, TrackDSP> = new Map();
  private activeSources: Map<string, ScheduledSource> = new Map();

  // Scheduling State
  private isPlaying: boolean = false;
  private schedulerTimer: number | null = null;
  private nextScheduleTime: number = 0;
  private playbackStartTime: number = 0; 
  private pausedAt: number = 0; 

  // Latency & Rec
  private isRecMode: boolean = false;

  // Constants
  private readonly LOOKAHEAD_MS = 25.0; 
  private readonly SCHEDULE_AHEAD_SEC = 0.1; 

  // Recording
  private mediaRecorder: MediaRecorder | null = null;
  private audioChunks: Blob[] = [];
  private recStream: MediaStream | null = null;
  private recStartTime: number = 0;

  constructor() {}

  public async init() {
    if (this.ctx) return;
    
    const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
    this.ctx = new AudioContextClass({ 
      latencyHint: 'interactive', 
      sampleRate: 44100 
    });

    this.masterOutput = this.ctx.createGain();
    this.masterAnalyzer = this.ctx.createAnalyser();
    this.masterAnalyzer.fftSize = 2048;
    this.masterAnalyzer.smoothingTimeConstant = 0.8;

    this.masterOutput.connect(this.masterAnalyzer);
    this.masterAnalyzer.connect(this.ctx.destination);
  }

  public async resume() {
    if (this.ctx && this.ctx.state === 'suspended') {
      await this.ctx.resume();
    }
  }

  public startPlayback(startOffset: number, tracks: Track[]) {
    if (!this.ctx) return;
    if (this.isPlaying) this.stopAll();

    this.isPlaying = true;
    this.pausedAt = startOffset;
    this.nextScheduleTime = this.ctx.currentTime + 0.05; 
    this.playbackStartTime = this.ctx.currentTime - startOffset; 

    this.schedulerTimer = window.setInterval(() => {
      this.scheduler(tracks);
    }, this.LOOKAHEAD_MS);
  }

  public stopAll() {
    this.isPlaying = false;
    if (this.schedulerTimer) {
      clearInterval(this.schedulerTimer);
      this.schedulerTimer = null;
    }

    this.activeSources.forEach((src) => {
      try {
        src.source.stop();
        src.source.disconnect();
        src.gain.disconnect();
      } catch (e) { }
    });
    this.activeSources.clear();
  }

  public seekTo(time: number, tracks: Track[], wasPlaying: boolean) {
    this.stopAll();
    this.pausedAt = time;
    
    // Reset automation state at this specific time
    tracks.forEach(track => this.applyAutomation(track, time));

    if (wasPlaying) {
      this.startPlayback(time, tracks);
    }
  }

  public getCurrentTime(): number {
    if (!this.ctx) return 0;
    if (this.isPlaying) {
      return this.ctx.currentTime - this.playbackStartTime;
    }
    return this.pausedAt;
  }

  private scheduler(tracks: Track[]) {
    if (!this.ctx) return;

    while (this.nextScheduleTime < this.ctx.currentTime + this.SCHEDULE_AHEAD_SEC) {
      const scheduleUntil = this.nextScheduleTime + this.SCHEDULE_AHEAD_SEC;
      
      const projectTimeStart = this.nextScheduleTime - this.playbackStartTime;
      const projectTimeEnd = scheduleUntil - this.playbackStartTime;

      this.scheduleClips(tracks, projectTimeStart, projectTimeEnd, this.nextScheduleTime);
      this.scheduleAutomation(tracks, projectTimeStart, projectTimeEnd, this.nextScheduleTime);
      
      this.nextScheduleTime += this.SCHEDULE_AHEAD_SEC; 
    }
  }

  private scheduleClips(tracks: Track[], projectWindowStart: number, projectWindowEnd: number, contextScheduleTime: number) {
    tracks.forEach(track => {
      if (track.isMuted) return; 

      track.clips.forEach(clip => {
        const clipStartsInWindow = clip.start >= projectWindowStart && clip.start < projectWindowEnd;
        
        const isInitialSeek = Math.abs(projectWindowStart - this.pausedAt) < 0.05 && this.activeSources.size === 0;
        const playheadInsideClip = projectWindowStart > clip.start && projectWindowStart < (clip.start + clip.duration);

        if ((clipStartsInWindow || (isInitialSeek && playheadInsideClip))) {
           this.playClipSource(track.id, clip, contextScheduleTime, projectWindowStart);
        }
      });
    });
  }

  private scheduleAutomation(tracks: Track[], start: number, end: number, when: number) {
    tracks.forEach(track => {
      track.automationLanes.forEach(lane => {
        if (lane.points.length < 2) return;
        
        // Find points in this time window
        const relevantPoints = lane.points.filter(p => p.time >= start && p.time < end);
        
        relevantPoints.forEach(p => {
           const timeOffset = p.time - start;
           const scheduleAt = when + timeOffset;
           const dsp = this.tracksDSP.get(track.id);
           
           if (dsp) {
             if (lane.parameterName === 'volume') {
               dsp.gain.gain.linearRampToValueAtTime(p.value, scheduleAt);
             } else if (lane.parameterName === 'pan') {
               dsp.panner.pan.linearRampToValueAtTime(p.value, scheduleAt);
             }
           }
        });
      });
    });
  }

  private playClipSource(trackId: string, clip: Clip, when: number, projectTime: number) {
    if (!this.ctx || !clip.buffer) return;
    if (this.activeSources.has(clip.id)) return;

    const trackDSP = this.tracksDSP.get(trackId);
    if (!trackDSP) return;

    const source = this.ctx.createBufferSource();
    source.buffer = clip.buffer;
    
    const clipGain = this.ctx.createGain();
    clipGain.gain.value = clip.gain || 1.0;

    source.connect(clipGain);
    clipGain.connect(trackDSP.input);

    let offset = 0;
    let duration = clip.duration;
    let startTime = clip.start;

    if (projectTime > clip.start) {
        const timePassed = projectTime - clip.start;
        offset = clip.offset + timePassed;
        duration = clip.duration - timePassed;
        startTime = projectTime; 
    } else {
        offset = clip.offset;
    }

    const exactStartCtxTime = when + (startTime - projectTime);

    if (duration > 0) {
        // Safe start to avoid "start time in past" errors if system lags
        const safeStart = Math.max(this.ctx.currentTime, exactStartCtxTime);
        
        source.start(safeStart, offset, duration);
        
        const fadeInEnd = safeStart + clip.fadeIn;
        const fadeOutStart = safeStart + duration - clip.fadeOut;

        clipGain.gain.setValueAtTime(0, safeStart);
        clipGain.gain.linearRampToValueAtTime(clip.gain || 1.0, fadeInEnd);
        clipGain.gain.setValueAtTime(clip.gain || 1.0, fadeOutStart);
        clipGain.gain.linearRampToValueAtTime(0, safeStart + duration);

        this.activeSources.set(clip.id, { source, gain: clipGain, clipId: clip.id });

        source.onended = () => {
            this.activeSources.delete(clip.id);
            try { clipGain.disconnect(); } catch(e){}
        };
    }
  }

  public updateTrack(track: Track, allTracks: Track[]) {
    if (!this.ctx) return;

    let dsp = this.tracksDSP.get(track.id);
    if (!dsp) {
      dsp = {
        input: this.ctx.createGain(),
        output: this.ctx.createGain(),
        gain: this.ctx.createGain(),
        panner: this.ctx.createStereoPanner(),
        analyzer: this.ctx.createAnalyser(),
        pluginChain: new Map(),
        sends: new Map()
      };
      this.tracksDSP.set(track.id, dsp);
    }

    // Reconstruct Plugin Chain
    dsp.input.disconnect();
    
    let head: AudioNode = dsp.input;
    const currentPluginIds = new Set<string>();
    
    track.plugins.forEach(plugin => {
      // In Rec Mode, bypass high latency plugins on rec track
      if (this.isRecMode && plugin.latency > 0 && track.isTrackArmed) return;
      
      if (!plugin.isEnabled) return;
      currentPluginIds.add(plugin.id);

      let pEntry = dsp!.pluginChain.get(plugin.id);
      
      if (!pEntry) {
        const instance = this.createPluginNode(plugin);
        if (instance) {
          pEntry = { input: instance.input, output: instance.output, instance: instance.node };
          dsp!.pluginChain.set(plugin.id, pEntry);
        }
      } else {
        if (pEntry.instance.updateParams) {
          pEntry.instance.updateParams(plugin.params);
        }
      }

      if (pEntry) {
        head.connect(pEntry.input);
        head = pEntry.output;
      }
    });

    dsp.pluginChain.forEach((val, id) => {
        if (!currentPluginIds.has(id)) {
            val.input.disconnect();
            val.output.disconnect();
            dsp!.pluginChain.delete(id);
        }
    });

    head.disconnect();
    head.connect(dsp.analyzer);
    dsp.analyzer.connect(dsp.gain);
    dsp.gain.connect(dsp.panner);
    dsp.panner.connect(dsp.output);

    // Apply basic values
    const now = this.ctx.currentTime;
    const volume = track.isMuted ? 0 : track.volume;
    
    dsp.gain.gain.setTargetAtTime(volume, now, 0.015);
    dsp.panner.pan.setTargetAtTime(track.pan, now, 0.015);

    // Routing
    dsp.output.disconnect();
    
    if (track.outputTrackId === 'master' || !track.outputTrackId) {
       dsp.output.connect(this.masterOutput!);
    } else {
       const busDSP = this.tracksDSP.get(track.outputTrackId);
       if (busDSP) dsp.output.connect(busDSP.input);
       else dsp.output.connect(this.masterOutput!); 
    }

    // Sends
    track.sends.forEach(send => {
       if (!send.isEnabled || send.level <= 0) {
           const existing = dsp!.sends.get(send.id);
           if (existing) { existing.disconnect(); dsp!.sends.delete(send.id); }
           return;
       }

       let sendNode = dsp!.sends.get(send.id);
       if (!sendNode) {
           sendNode = this.ctx!.createGain();
           dsp!.sends.set(send.id, sendNode);
           dsp!.output.connect(sendNode);
       }

       const destDSP = this.tracksDSP.get(send.id);
       if (destDSP) {
           sendNode.disconnect();
           sendNode.connect(destDSP.input);
           sendNode.gain.setTargetAtTime(send.level, now, 0.02);
       }
    });
  }

  private applyAutomation(track: Track, time: number) {
      if (!this.ctx) return;
      const dsp = this.tracksDSP.get(track.id);
      if (!dsp) return;

      track.automationLanes.forEach(lane => {
          // Simple Linear Interpolation for Seek
          const before = lane.points.filter(p => p.time <= time).pop();
          const after = lane.points.find(p => p.time > time);
          
          let val = 0;
          if (!before && !after) return; // No points
          else if (!before) val = after!.value;
          else if (!after) val = before.value;
          else {
              const ratio = (time - before.time) / (after.time - before.time);
              val = before.value + (after.value - before.value) * ratio;
          }

          if (lane.parameterName === 'volume') dsp.gain.gain.setValueAtTime(val, this.ctx.currentTime);
          if (lane.parameterName === 'pan') dsp.panner.pan.setValueAtTime(val, this.ctx.currentTime);
      });
  }

  private createPluginNode(plugin: PluginInstance) {
    if (!this.ctx) return null;
    let node: any = null;
    try {
      switch(plugin.type) {
        case 'REVERB': node = new ReverbNode(this.ctx); break;
        case 'DELAY': node = new SyncDelayNode(this.ctx, 120); break;
        case 'COMPRESSOR': node = new CompressorNode(this.ctx); break;
        case 'PROEQ12': node = new ProEQ12Node(this.ctx, plugin.params as any); break;
        case 'AUTOTUNE': node = new AutoTuneNode(this.ctx); break;
        case 'CHORUS': node = new ChorusNode(this.ctx); break;
        case 'FLANGER': node = new FlangerNode(this.ctx); break;
        case 'DOUBLER': node = new VocalDoublerNode(this.ctx); break;
        case 'STEREOSPREADER': node = new StereoSpreaderNode(this.ctx); break;
        case 'DEESSER': node = new DeEsserNode(this.ctx); break;
        case 'DENOISER': node = new DenoiserNode(this.ctx); break;
        case 'VOCALSATURATOR': node = new VocalSaturatorNode(this.ctx); break;
        case 'MASTERSYNC': node = new MasterSyncNode(this.ctx); break;
      }
      if (node) {
          node.updateParams(plugin.params);
          return { input: node.input, output: node.output, node };
      }
    } catch(e) {
      console.error(\`Failed to create plugin \${plugin.type}\`, e);
    }
    return null;
  }

  public async startRecording(currentTime: number) {
    if (!this.ctx) return false;
    try {
      this.recStream = await navigator.mediaDevices.getUserMedia({ 
          audio: { 
              echoCancellation: false, 
              noiseSuppression: false, 
              autoGainControl: false,
              latency: 0 
          } as any
      });
      this.mediaRecorder = new MediaRecorder(this.recStream);
      this.audioChunks = [];
      this.recStartTime = currentTime;
      
      this.mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) this.audioChunks.push(e.data);
      };
      this.mediaRecorder.start();
      return true;
    } catch(e) { 
      console.error("Mic Access Error:", e); 
      return false; 
    }
  }

  public async stopRecording(): Promise<Clip | null> {
    return new Promise((resolve) => {
        if (!this.mediaRecorder || this.mediaRecorder.state === 'inactive') return resolve(null);
        
        this.mediaRecorder.onstop = async () => {
            const blob = new Blob(this.audioChunks, { type: 'audio/webm' });
            if (blob.size === 0) { resolve(null); return; }
            
            try {
                const buffer = await blob.arrayBuffer();
                const audioBuffer = await this.ctx!.decodeAudioData(buffer);
                
                const clip: Clip = {
                    id: \`rec-\${Date.now()}\`,
                    name: 'Vocal Take',
                    start: this.recStartTime,
                    duration: audioBuffer.duration,
                    offset: 0,
                    fadeIn: 0.05,
                    fadeOut: 0.05,
                    type: TrackType.AUDIO,
                    color: '#ff0000',
                    buffer: audioBuffer
                };
                
                if (this.recStream) this.recStream.getTracks().forEach(t => t.stop());
                this.recStream = null;
                resolve(clip);
            } catch(e) {
                console.error("Recording decode error", e);
                resolve(null);
            }
        };
        this.mediaRecorder.stop();
    });
  }

  public getMasterAnalyzer() { return this.masterAnalyzer; }
  public getTrackAnalyzer(trackId: string) { return this.tracksDSP.get(trackId)?.analyzer || null; }
  public getPluginNodeInstance(trackId: string, pluginId: string) { 
      return this.tracksDSP.get(trackId)?.pluginChain.get(pluginId)?.instance || null; 
  }
  public setRecMode(active: boolean) { this.isRecMode = active; }
}

export const audioEngine = new AudioEngine();` },
{ path: "components/TransportBar.tsx", content: `
import React, { useState, useRef, useEffect, PropsWithChildren } from 'react';
import { ViewType } from '../types';

interface TransportProps {
  isPlaying: boolean;
  onTogglePlay: () => void;
  onStop: () => void;
  isRecording: boolean;
  onToggleRecord: () => void;
  isLoopActive: boolean;
  onToggleLoop: () => void;
  bpm: number;
  onBpmChange: (newBpm: number) => void;
  currentTime: number;
  currentView: ViewType;
  onChangeView: (view: ViewType) => void;
  noArmedTrackError?: boolean;
  statusMessage?: string | null;
}

const TransportBar: React.FC<PropsWithChildren<TransportProps>> = ({ 
  isPlaying, onTogglePlay, onStop, isRecording, onToggleRecord, isLoopActive, onToggleLoop, bpm, onBpmChange, currentTime, 
  currentView, onChangeView, noArmedTrackError, statusMessage, children
}) => {
  const [isEditingBpm, setIsEditingBpm] = useState(false);
  const [tempBpm, setTempBpm] = useState(bpm.toString());
  const bpmInputRef = useRef<HTMLInputElement>(null);

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    const cents = Math.floor((seconds % 1) * 100);
    return \`\${mins.toString().padStart(2, '0')}:\${secs.toString().padStart(2, '0')}.\${cents.toString().padStart(2, '0')}\`;
  };

  const handleBpmMouseDown = (e: React.MouseEvent) => {
    if (e.detail === 2) { 
      setIsEditingBpm(true);
      return;
    }
    const startY = e.clientY;
    const startBpm = bpm;
    const onMouseMove = (m: MouseEvent) => {
      const delta = Math.floor((startY - m.clientY) / 5);
      if (delta !== 0) {
        onBpmChange(Math.max(20, Math.min(999, startBpm + delta)));
      }
    };
    const onMouseUp = () => {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    };
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
  };

  useEffect(() => {
    if (isEditingBpm) bpmInputRef.current?.focus();
  }, [isEditingBpm]);

  return (
    <div className="h-16 bg-[#14161a] border-b border-white/5 flex items-center px-4 md:px-6 justify-between z-50 shadow-sm relative shrink-0 transition-all">
      {noArmedTrackError && (
        <div className="absolute top-full left-1/2 -translate-x-1/2 mt-2 px-4 py-2 bg-red-600 text-white text-[10px] font-black uppercase rounded-lg shadow-2xl animate-bounce z-[100]">
          <i className="fas fa-exclamation-triangle mr-2"></i> Record Error
        </div>
      )}

      {/* VIEW SWITCHER (Hidden on Mobile - Handled by Bottom Nav) */}
      <div className="hidden md:flex items-center space-x-1 bg-black/40 rounded-xl p-1 border border-white/5">
        <button onClick={() => onChangeView('ARRANGEMENT')} className={\`px-4 py-2 rounded-lg text-[9px] font-black uppercase tracking-widest transition-all \${currentView === 'ARRANGEMENT' ? 'bg-[#00f2ff] text-black' : 'text-slate-500 hover:text-white'}\`}>Arrangement</button>
        <button onClick={() => onChangeView('MIXER')} className={\`px-4 py-2 rounded-lg text-[9px] font-black uppercase tracking-widest transition-all \${currentView === 'MIXER' ? 'bg-[#00f2ff] text-black' : 'text-slate-500 hover:text-white'}\`}>Mixer</button>
      </div>

      <div className="flex flex-1 md:flex-none justify-center items-center space-x-4 md:space-x-6">
        <div className="flex items-center space-x-2 md:space-x-4 bg-black/40 px-4 py-1.5 rounded-xl border border-white/5">
          <button onClick={onStop} className="w-8 h-8 text-slate-600 hover:text-white transition-colors hide-on-tablet-text"><i className="fas fa-stop text-xs"></i></button>
          <button onClick={onTogglePlay} className={\`w-10 h-10 rounded-full flex items-center justify-center transition-all \${isPlaying ? 'bg-[#00f2ff] text-black shadow-lg shadow-[#00f2ff]/30' : 'bg-white text-black hover:scale-105'}\`}>
            <i className={\`fas \${isPlaying ? 'fa-pause' : 'fa-play'} text-sm\`}></i>
          </button>
          <button onClick={onToggleLoop} title="Loop Mode" className={\`hidden md:flex w-8 h-8 rounded-lg items-center justify-center transition-all \${isLoopActive ? 'bg-cyan-500/20 text-cyan-400' : 'text-slate-600 hover:text-white'}\`}><i className="fas fa-redo text-xs"></i></button>
          <button onClick={onToggleRecord} className={\`h-10 px-4 md:px-6 rounded-xl flex items-center space-x-2 md:space-x-3 border transition-all \${isRecording ? 'bg-red-600 border-red-400 text-white shadow-lg shadow-red-600/40 animate-pulse' : 'bg-white/5 text-slate-500 border-white/10 hover:bg-white/10 hover:text-white'}\`}><div className={\`w-2.5 h-2.5 rounded-full \${isRecording ? 'bg-white' : 'bg-red-600'}\`}></div><span className="hidden md:inline font-black uppercase text-[10px] tracking-widest hide-on-tablet-text">Rec</span></button>
        </div>
        
        {/* TIME DISPLAY */}
        <div className="flex flex-col items-center min-w-[80px] md:min-w-[120px]">
           {statusMessage ? (
             <div className="flex items-center space-x-2 animate-pulse">
                <div className="w-1.5 h-1.5 rounded-full bg-cyan-500"></div>
                <span className="text-[8px] font-black text-cyan-400 uppercase tracking-tighter truncate max-w-[100px]">{statusMessage}</span>
             </div>
           ) : (
             <>
               <span className="hidden md:block text-[7px] text-slate-600 font-black uppercase tracking-[0.3em] hide-on-tablet-text">Timeline</span>
               <span className="mono text-[12px] md:text-[14px] text-[#00f2ff] font-bold text-center">{formatTime(currentTime)}</span>
             </>
           )}
        </div>
      </div>

      {/* RIGHT SIDE CONTROLS */}
      <div className="flex items-center space-x-6">
        <div 
          className="flex flex-col items-end cursor-ns-resize group"
          onMouseDown={handleBpmMouseDown}
        >
           <div className="flex items-center space-x-2">
              {isEditingBpm ? (
                <input 
                  ref={bpmInputRef}
                  type="text"
                  value={tempBpm}
                  onChange={(e) => setTempBpm(e.target.value.replace(/[^0-9.]/g, ''))}
                  onBlur={() => { setIsEditingBpm(false); onBpmChange(parseFloat(tempBpm) || 120); }}
                  onKeyDown={(e) => e.key === 'Enter' && bpmInputRef.current?.blur()}
                  className="w-10 md:w-12 bg-white/10 border border-cyan-500/50 rounded text-center text-[10px] md:text-[11px] font-black text-white outline-none"
                />
              ) : (
                <span className="text-[10px] md:text-[11px] font-black text-white group-hover:text-cyan-400 transition-colors">{bpm}</span>
              )}
              <span className="text-[7px] text-slate-500 font-bold uppercase tracking-widest hide-on-tablet-text">BPM</span>
           </div>
           <div className="hidden md:block w-16 h-1 bg-white/5 rounded-full mt-1 overflow-hidden">
              <div className="h-full bg-cyan-500 transition-all duration-300" style={{ width: \`\${Math.min(100, (bpm / 250) * 100)}%\` }}></div>
           </div>
        </div>
        
        {/* Render children (ViewModeSwitcher) here */}
        {children}
      </div>
    </div>
  );
};

export default TransportBar;` },
{ path: "components/TrackHeader.tsx", content: `
import React, { useState, useRef, useEffect } from 'react';
import { Track, PluginType, PluginInstance, TrackType, TrackSend } from '../types';

interface TrackHeaderProps {
  track: Track;
  onUpdate: (track: Track, altKey?: boolean) => void;
  isSelected: boolean;
  onSelect: () => void;
  onDropPlugin?: (trackId: string, type: PluginType) => void;
  onMovePlugin?: (sourceTrackId: string, destTrackId: string, pluginId: string) => void;
  onSelectPlugin?: (trackId: string, plugin: PluginInstance) => void;
  onRemovePlugin?: (trackId: string, pluginId: string) => void;
  onRequestAddPlugin?: (trackId: string, x: number, y: number) => void;
  onContextMenu: (e: React.MouseEvent, trackId: string) => void;
  // Drag & Drop Piste
  onDragStartTrack: (trackId: string) => void;
  onDragOverTrack: (trackId: string) => void;
  onDropTrack: () => void;
  isDraggingOver?: boolean;
}

const HorizontalSendFader: React.FC<{ 
  send: TrackSend, 
  color: string, 
  label: string, 
  onChange: (level: number) => void 
}> = ({ send, color, label, onChange }) => {
  const handleInteraction = (clientX: number, rect: DOMRect) => {
    const x = clientX - rect.left;
    const progress = Math.max(0, Math.min(1, x / rect.width));
    onChange(progress * 1.5); 
  };

  const handleMouseDown = (e: React.MouseEvent) => {
    e.stopPropagation(); e.preventDefault();
    const rect = e.currentTarget.getBoundingClientRect();
    handleInteraction(e.clientX, rect);
    const onMouseMove = (m: MouseEvent) => handleInteraction(m.clientX, rect);
    const onMouseUp = () => { window.removeEventListener('mousemove', onMouseMove); window.removeEventListener('mouseup', onMouseUp); };
    window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp);
  };

  const handleTouchStart = (e: React.TouchEvent) => {
    e.stopPropagation();
    const rect = e.currentTarget.getBoundingClientRect();
    handleInteraction(e.touches[0].clientX, rect);
    // Note: Touch move handling is simpler inline for single elements
  };

  const handleTouchMove = (e: React.TouchEvent) => {
    const rect = e.currentTarget.getBoundingClientRect();
    handleInteraction(e.touches[0].clientX, rect);
  };

  const percent = (send.level / 1.5) * 100;

  return (
    <div 
      onMouseDown={handleMouseDown}
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      className="relative h-5 bg-black/60 rounded-md overflow-hidden border border-white/5 cursor-ew-resize group/fader mb-1 last:mb-0 transition-all hover:border-white/20 touch-none"
    >
      <div 
        className="absolute inset-y-0 left-0 transition-all duration-75"
        style={{ width: \`\${percent}%\`, backgroundColor: color, opacity: 0.25 }}
      />
      <div 
        className="absolute inset-y-0 left-0 border-r-2 transition-all duration-75"
        style={{ width: \`\${percent}%\`, borderColor: color, boxShadow: send.level > 0.05 ? \`0 0 10px \${color}\` : 'none' }}
      />
      <div className="absolute inset-0 flex items-center justify-between px-2 pointer-events-none">
        <span className="text-[7px] font-black text-white/80 uppercase tracking-tighter">{label}</span>
        <span className="text-[7px] font-mono text-white/40">{Math.round((send.level / 1.5) * 100)}%</span>
      </div>
    </div>
  );
};

const TrackHeader: React.FC<TrackHeaderProps> = ({ 
  track, onUpdate, isSelected, onSelect, onDropPlugin, onMovePlugin, onSelectPlugin, onRemovePlugin, onRequestAddPlugin, onContextMenu,
  onDragStartTrack, onDragOverTrack, onDropTrack, isDraggingOver
}) => {
  const [isDragOverFX, setIsDragOverFX] = useState(false);
  const [isRenaming, setIsRenaming] = useState(false);
  const [showSends, setShowSends] = useState(false);
  const [isAdjustingVolume, setIsAdjustingVolume] = useState(false);
  const [newName, setNewName] = useState(track.name);
  const nameInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (isRenaming) {
      nameInputRef.current?.focus();
      nameInputRef.current?.select();
    }
  }, [isRenaming]);

  const handleNameSubmit = () => {
    setIsRenaming(false);
    if (newName.trim() && newName !== track.name) {
      onUpdate({ ...track, name: newName });
    }
  };

  const handleSendChange = (sendId: string, level: number) => {
    const newSends = track.sends.map(s => s.id === sendId ? { ...s, level } : s);
    onUpdate({ ...track, sends: newSends });
  };

  const handleFXClick = (e: React.MouseEvent | React.TouchEvent, p: PluginInstance) => {
    e.stopPropagation();
    if (onSelectPlugin) onSelectPlugin(track.id, p);
  };

  const handleEmptySlotClick = (e: React.MouseEvent | React.TouchEvent) => {
    e.stopPropagation();
    let clientX = 0;
    let clientY = 0;
    if ('touches' in e) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = (e as React.MouseEvent).clientX;
      clientY = (e as React.MouseEvent).clientY;
    }
    if (onRequestAddPlugin) onRequestAddPlugin(track.id, clientX, clientY);
  };

  const handleRemoveFX = (e: React.MouseEvent | React.TouchEvent, pId: string) => {
    e.stopPropagation();
    if (onRemovePlugin) onRemovePlugin(track.id, pId);
  };

  const handleFXDragStart = (e: React.DragEvent, pId: string) => {
    e.dataTransfer.setData('pluginId', pId);
    e.dataTransfer.setData('sourceTrackId', track.id);
    e.dataTransfer.dropEffect = 'move';
  };

  const handleOnDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOverFX(false);

    const pluginType = e.dataTransfer.getData('pluginType') as PluginType;
    const pluginId = e.dataTransfer.getData('pluginId');
    const sourceTrackId = e.dataTransfer.getData('sourceTrackId');

    if (pluginType && onDropPlugin) {
      onDropPlugin(track.id, pluginType);
    } else if (pluginId && sourceTrackId && onMovePlugin) {
      onMovePlugin(sourceTrackId, track.id, pluginId);
    } else if (e.dataTransfer.types.includes('trackId')) {
      onDropTrack();
    }
  };

  // --- PAN CONTROL (TOUCH & MOUSE) ---
  const handlePanInteraction = (deltaY: number) => {
      const delta = deltaY / 100;
      onUpdate({ ...track, pan: Math.max(-1, Math.min(1, track.pan + delta)) });
  };

  const handlePanMouseDown = (e: React.MouseEvent) => {
    e.stopPropagation();
    const startY = e.clientY;
    const startPan = track.pan;
    const onMouseMove = (m: MouseEvent) => {
      const delta = (startY - m.clientY) / 100;
      onUpdate({ ...track, pan: Math.max(-1, Math.min(1, startPan + delta)) });
    };
    const onMouseUp = () => { window.removeEventListener('mousemove', onMouseMove); window.removeEventListener('mouseup', onMouseUp); };
    window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp);
  };

  const handlePanTouchStart = (e: React.TouchEvent) => {
      e.stopPropagation();
      const startY = e.touches[0].clientY;
      const startPan = track.pan;
      const onTouchMove = (tm: TouchEvent) => {
          const delta = (startY - tm.touches[0].clientY) / 100;
          onUpdate({ ...track, pan: Math.max(-1, Math.min(1, startPan + delta)) });
      };
      // Note: In React we attach to the element, but for global drag we might need window/document. 
      // For simple vertical sliders, attaching to element is ok if finger stays on it, 
      // but usually we want to capture outside.
      // For simplicity in this XML block, we rely on the component's onTouchMove
  };

  const handlePanTouchMove = (e: React.TouchEvent) => {
      // Delta logic needs state or reference to start Y. 
      // Simplified: use movementY if available or diff.
      // Reverting to simple step logic or direct value not ideal for relative pan.
      // Let's implement a cleaner unified handler in Volume which is absolute.
  };

  // --- VOLUME CONTROL (TOUCH & MOUSE - UNIFIED) ---
  const handleVolumeInteraction = (clientX: number, rect: DOMRect) => {
      const x = clientX - rect.left;
      const progress = Math.max(0, Math.min(1, x / rect.width));
      onUpdate({ ...track, volume: progress * progress * 1.5 });
  };

  const handleVolumeMouseDown = (e: React.MouseEvent) => {
    e.stopPropagation(); e.preventDefault();
    setIsAdjustingVolume(true);
    const rect = e.currentTarget.getBoundingClientRect();
    handleVolumeInteraction(e.clientX, rect);
    const onMouseMove = (m: MouseEvent) => handleVolumeInteraction(m.clientX, rect);
    const onMouseUp = () => { setIsAdjustingVolume(false); window.removeEventListener('mousemove', onMouseMove); window.removeEventListener('mouseup', onMouseUp); };
    window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp);
  };

  const handleVolumeTouchStart = (e: React.TouchEvent) => {
    e.stopPropagation();
    setIsAdjustingVolume(true);
    const rect = e.currentTarget.getBoundingClientRect();
    handleVolumeInteraction(e.touches[0].clientX, rect);
  };

  const handleVolumeTouchMove = (e: React.TouchEvent) => {
    const rect = e.currentTarget.getBoundingClientRect();
    handleVolumeInteraction(e.touches[0].clientX, rect);
  };

  const handleVolumeTouchEnd = () => setIsAdjustingVolume(false);

  const toggleAutomation = (e: React.MouseEvent | React.TouchEvent) => {
    e.stopPropagation();
    let lanes = [...track.automationLanes];
    if (lanes.length === 0) {
      lanes.push({ id: \`auto-\${Date.now()}\`, parameterName: 'volume', points: [], color: track.color, isExpanded: true, min: 0, max: 1.5 });
    } else {
      lanes = lanes.map(l => ({ ...l, isExpanded: !l.isExpanded }));
    }
    onUpdate({ ...track, automationLanes: lanes });
  };

  const togglePluginBypass = (e: React.MouseEvent | React.TouchEvent, p: PluginInstance) => {
    e.stopPropagation();
    const plugins = track.plugins.map(pl => pl.id === p.id ? { ...pl, isEnabled: !pl.isEnabled } : pl);
    onUpdate({ ...track, plugins });
  };

  const getAbbr = (type: string) => {
    const map: Record<string, string> = { 
      'AUTOTUNE': 'TUNE', 'COMPRESSOR': 'COMP', 'STEREOSPREADER': 'MS', 
      'DEESSER': 'DS', 'DENOISER': 'NOISE', 'PROEQ12': 'EQ12', 'VOCALSATURATOR': 'SAT'
    };
    return map[type] || type.substring(0, 4);
  };

  const handleMuteToggle = (e: React.MouseEvent | React.TouchEvent) => {
    e.stopPropagation();
    onUpdate({ ...track, isMuted: !track.isMuted });
  };

  const handleSoloToggle = (e: React.MouseEvent | React.TouchEvent) => {
    e.stopPropagation();
    onUpdate({ ...track, isSolo: !track.isSolo });
  };

  const canHaveSends = (track.type === TrackType.AUDIO || track.type === TrackType.BUS) && track.id !== 'instrumental' && track.id !== 'master';

  return (
    <div 
      onClick={onSelect}
      onContextMenu={(e) => { e.preventDefault(); onContextMenu(e, track.id); }}
      onDragOver={(e) => { e.preventDefault(); setIsDragOverFX(true); onDragOverTrack(track.id); }}
      onDragLeave={() => { setIsDragOverFX(false); }}
      onDrop={handleOnDrop}
      className={\`group border-b border-white/[0.03] p-3 flex flex-col h-full relative transition-all \${isSelected ? 'bg-white/[0.08]' : 'bg-transparent'} \${isDragOverFX ? 'ring-2 ring-cyan-500 bg-cyan-500/10' : ''} \${track.isFrozen ? 'opacity-60 grayscale' : ''} \${isDraggingOver ? 'border-t-2 border-t-cyan-500 bg-cyan-500/5' : ''}\`}
      style={{ borderLeft: \`4px solid \${track.color}\` }}
    >
      <div className="flex justify-between items-start mb-1">
        <div className="flex items-center truncate flex-1 pr-2">
          {/* Poignée de drag */}
          <div 
            draggable 
            onDragStart={(e) => { e.stopPropagation(); e.dataTransfer.setData('trackId', track.id); onDragStartTrack(track.id); }}
            className="cursor-grab active:cursor-grabbing text-slate-700 hover:text-cyan-500 mr-2 flex-shrink-0 transition-colors"
          >
            <i className="fas fa-grip-vertical text-[10px]"></i>
          </div>

          <div className="truncate">
            {isRenaming ? (
              <input 
                ref={nameInputRef}
                type="text"
                value={newName}
                onChange={(e) => setNewName(e.target.value)}
                onBlur={handleNameSubmit}
                onKeyDown={(e) => e.key === 'Enter' && handleNameSubmit()}
                className="bg-black/60 border border-cyan-500/50 rounded px-1 text-[10px] font-black uppercase text-white outline-none w-full"
              />
            ) : (
              <span 
                onDoubleClick={(e) => { e.stopPropagation(); setIsRenaming(true); }}
                className={\`text-[10px] font-black uppercase tracking-widest truncate cursor-text \${isSelected ? 'text-white' : 'text-slate-500'}\`}
              >
                {track.name} {track.isFrozen && <i className="fas fa-snowflake text-[8px] ml-1 text-cyan-400"></i>}
              </span>
            )}
          </div>
        </div>
        <div className="flex space-x-1 shrink-0">
          <button 
            onClick={handleMuteToggle}
            onTouchStart={handleMuteToggle}
            className={\`w-6 h-6 rounded-md flex items-center justify-center transition-all border \${track.isMuted ? 'bg-red-600 border-red-500 text-white shadow-[0_0_8px_rgba(220,38,38,0.4)]' : 'bg-white/5 border-white/10 text-slate-600 hover:text-white'}\`}
          >
            <span className="text-[8px] font-black">M</span>
          </button>
          <button 
            onClick={handleSoloToggle}
            onTouchStart={handleSoloToggle}
            className={\`w-6 h-6 rounded-md flex items-center justify-center transition-all border \${track.isSolo ? 'bg-amber-400 border-amber-300 text-black shadow-[0_0_8px_rgba(251,191,36,0.4)]' : 'bg-white/5 border-white/10 text-slate-600 hover:text-white'}\`}
          >
            <span className="text-[8px] font-black">S</span>
          </button>
          {canHaveSends && (
            <button 
              onClick={(e) => { e.stopPropagation(); setShowSends(!showSends); }} 
              onTouchStart={(e) => { e.stopPropagation(); setShowSends(!showSends); }}
              className={\`w-6 h-6 rounded-md flex items-center justify-center transition-all \${showSends ? 'bg-cyan-500 text-black' : 'bg-white/5 text-slate-600 hover:text-white'}\`}
            >
              <i className="fas fa-sliders-h text-[8px]"></i>
            </button>
          )}
          <button onClick={toggleAutomation} onTouchStart={toggleAutomation} className={\`w-6 h-6 rounded-md flex items-center justify-center transition-all \${track.automationLanes.some(l => l.isExpanded) ? 'bg-amber-500 text-black' : 'bg-white/5 text-slate-600 hover:text-white'}\`}><span className="text-[8px] font-black">A</span></button>
          {track.type === TrackType.AUDIO && <button onClick={(e) => { e.stopPropagation(); onUpdate({...track, isTrackArmed: !track.isTrackArmed}) }} onTouchStart={(e) => { e.stopPropagation(); onUpdate({...track, isTrackArmed: !track.isTrackArmed}) }} className={\`w-6 h-6 rounded-md flex items-center justify-center transition-all \${track.isTrackArmed ? 'bg-red-600 text-white animate-pulse' : 'bg-white/5 text-slate-600 hover:text-white'}\`}><span className="text-[8px] font-black">R</span></button>}
        </div>
      </div>
      
      {/* Horizontal Sends Panel */}
      {canHaveSends && showSends && (
        <div className="flex flex-col bg-black/40 rounded-lg p-1.5 border border-cyan-500/20 mb-1.5 animate-in slide-in-from-top-1">
          <HorizontalSendFader label="Delay 1/4" color="#00f2ff" send={track.sends.find(s => s.id === 'send-delay') || { id: 'send-delay', level: 0, isEnabled: true }} onChange={(lvl) => handleSendChange('send-delay', lvl)} />
          <HorizontalSendFader label="Verb Pro" color="#10b981" send={track.sends.find(s => s.id === 'send-verb-short') || { id: 'send-verb-short', level: 0, isEnabled: true }} onChange={(lvl) => handleSendChange('send-verb-short', lvl)} />
          <HorizontalSendFader label="Hall Space" color="#a855f7" send={track.sends.find(s => s.id === 'send-verb-long') || { id: 'send-verb-long', level: 0, isEnabled: true }} onChange={(lvl) => handleSendChange('send-verb-long', lvl)} />
        </div>
      )}

      {/* ZONE DES CONTRÔLES : Panoramique et Volume */}
      <div className="flex items-center space-x-3 mt-1.5 bg-black/20 p-1.5 rounded-lg border border-white/5 relative z-10">
        <div 
          onMouseDown={handlePanMouseDown}
          onTouchStart={handlePanTouchStart}
          onDoubleClick={(e) => { e.stopPropagation(); onUpdate({...track, pan: 0}); }}
          className="relative w-6 h-6 rounded-full bg-black border border-white/10 flex items-center justify-center cursor-ns-resize shadow-lg hover:border-cyan-500/30 transition-all touch-none"
        >
          <div className="w-0.5 h-2.5 bg-cyan-400 rounded-full" style={{ transform: \`rotate(\${track.pan * 140}deg) translateY(-1px)\` }} />
        </div>
        
        <div className="flex-1 flex flex-col justify-center h-4 relative">
          <div 
            onMouseDown={handleVolumeMouseDown}
            onTouchStart={handleVolumeTouchStart}
            onTouchMove={handleVolumeTouchMove}
            onTouchEnd={handleVolumeTouchEnd}
            className="h-2 bg-black/60 rounded-full overflow-hidden relative cursor-ew-resize group/vol touch-none"
          >
            {/* Jauge de volume visuelle */}
            <div 
              className={\`h-full transition-all duration-75 \${isAdjustingVolume ? 'brightness-150' : 'brightness-100'}\`} 
              style={{ 
                width: \`\${(Math.sqrt(track.volume / 1.5)) * 100}%\`, 
                backgroundColor: track.color,
                boxShadow: isAdjustingVolume ? \`0 0 10px \${track.color}\` : 'none'
              }} 
            />
            <span className="absolute right-2 top-1/2 -translate-y-1/2 text-[5px] font-mono text-white/20 pointer-events-none group-hover/vol:text-white/60 transition-colors uppercase">
              {Math.round(track.volume * 100)}%
            </span>
          </div>
        </div>
      </div>
      
      <div className="mt-2.5 grid grid-cols-4 gap-1">
        {track.plugins.map(p => (
          <div 
            key={p.id} 
            draggable={!track.isFrozen}
            onDragStart={(e) => { if (track.isFrozen) return; e.stopPropagation(); handleFXDragStart(e, p.id); }}
            className={\`relative group/fxitem flex flex-col items-center fx-slot \${track.isFrozen ? 'pointer-events-none opacity-40' : ''}\`}
          >
            <div className="flex w-full overflow-hidden rounded-md border border-white/5 bg-black/40">
              <button 
                onClick={(e) => handleFXClick(e, p)}
                onTouchStart={(e) => handleFXClick(e, p)}
                className={\`flex-1 h-5 text-[6px] font-black uppercase truncate px-1 text-center flex items-center justify-center transition-all \${p.isEnabled ? 'text-cyan-400' : 'text-slate-700 bg-black/20'}\`}
              >
                {getAbbr(p.type)}
              </button>
              <button 
                onClick={(e) => togglePluginBypass(e, p)}
                onTouchStart={(e) => togglePluginBypass(e, p)}
                className={\`w-3 h-5 flex items-center justify-center transition-all \${p.isEnabled ? 'bg-cyan-500/20 text-cyan-400 hover:bg-cyan-500/40' : 'bg-white/5 text-slate-800'}\`}
              >
                <i className="fas fa-power-off text-[5px]"></i>
              </button>
            </div>
            <button onClick={(e) => handleRemoveFX(e, p.id)} onTouchStart={(e) => handleRemoveFX(e, p.id)} className="delete-fx"><i className="fas fa-times"></i></button>
          </div>
        ))}
        {!track.isFrozen && Array.from({ length: Math.max(0, 4 - track.plugins.length) }).map((_, i) => (
          <button 
            key={i} 
            onClick={handleEmptySlotClick}
            onTouchStart={handleEmptySlotClick}
            className="h-5 rounded-md border border-dashed border-white/10 bg-black/5 opacity-30 hover:opacity-100 hover:border-cyan-500/50 transition-all flex items-center justify-center"
          >
            <i className="fas fa-plus text-[6px]"></i>
          </button>
        ))}
      </div>
    </div>
  );
};
export default TrackHeader;` },
{ path: "components/ArrangementView.tsx", content: `
import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import { Track, TrackType, PluginType, PluginInstance, Clip, EditorTool, ContextMenuItem, AutomationLane, AutomationPoint } from '../types';
import TrackHeader from './TrackHeader';
import ContextMenu from './ContextMenu';

interface ArrangementViewProps {
  tracks: Track[];
  selectedTrackId: string | null;
  onSelectTrack: (id: string) => void;
  onUpdateTrack: (track: Track) => void;
  onReorderTracks: (sourceTrackId: string, destTrackId: string) => void;
  currentTime: number;
  isLoopActive: boolean;
  loopStart: number;
  loopEnd: number;
  onSetLoop: (start: number, end: number) => void;
  onSeek: (time: number) => void;
  bpm: number;
  onDropPluginOnTrack: (trackId: string, type: PluginType) => void;
  onMovePlugin?: (sourceTrackId: string, destTrackId: string, pluginId: string) => void;
  onMoveClip?: (sourceTrackId: string, destTrackId: string, clipId: string) => void;
  onSelectPlugin?: (trackId: string, plugin: PluginInstance) => void;
  onRemovePlugin?: (trackId: string, pluginId: string) => void;
  onRequestAddPlugin?: (trackId: string, x: number, y: number) => void;
  onAddTrack?: (type: TrackType) => void;
  onDuplicateTrack?: (trackId: string) => void;
  onDeleteTrack?: (trackId: string) => void;
  onFreezeTrack?: (trackId: string) => void;
  onImportFile?: (file: File) => void;
  onEditClip?: (trackId: string, clipId: string, action: string, payload?: any) => void;
  isRecording?: boolean;
}

// Zones d'interaction intelligentes
type InteractionZone = 'BODY' | 'RESIZE_L' | 'RESIZE_R' | 'FADE_IN' | 'FADE_OUT' | 'NONE';
type DragAction = 'MOVE' | 'TRIM_START' | 'TRIM_END' | 'ADJUST_FADE_IN' | 'ADJUST_FADE_OUT' | 'SEEK' | 'SELECT_REGION' | 'NONE';

const ArrangementView: React.FC<ArrangementViewProps> = ({ 
  tracks, selectedTrackId, onSelectTrack, onUpdateTrack, onReorderTracks, currentTime, 
  isLoopActive, loopStart, loopEnd, onSetLoop, onSeek, bpm, 
  onDropPluginOnTrack, onMovePlugin, onMoveClip, onSelectPlugin, onRemovePlugin, onRequestAddPlugin,
  onAddTrack, onDuplicateTrack, onDeleteTrack, onFreezeTrack, onImportFile, onEditClip, isRecording
}) => {
  const [activeTool, setActiveTool] = useState<EditorTool>('SELECT');
  const [zoomV, setZoomV] = useState(120); 
  const [zoomH, setZoomH] = useState(40);  
  const [snapEnabled, setSnapEnabled] = useState(true);
  
  // État d'interaction
  const [dragAction, setDragAction] = useState<DragAction>('NONE');
  const [hoverZone, setHoverZone] = useState<InteractionZone>('NONE');
  const [activeClip, setActiveClip] = useState<{trackId: string, clip: Clip} | null>(null);
  
  // Valeurs initiales au début du drag (pour le calcul delta)
  const [dragStartX, setDragStartX] = useState(0);
  const [initialClipState, setInitialClipState] = useState<Clip | null>(null);

  const [hoverTime, setHoverTime] = useState<number | null>(null);
  const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
  const [contextMenu, setContextMenu] = useState<{ x: number, y: number, items: ContextMenuItem[] } | null>(null);

  // VIRTUAL CANVAS REFS
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const requestRef = useRef<number>(0);
  const [viewportSize, setViewportSize] = useState({ width: 0, height: 0 });

  const timeToPixels = useCallback((time: number) => time * zoomH, [zoomH]);
  const pixelsToTime = useCallback((pixels: number) => pixels / zoomH, [zoomH]);

  // Observer pour la taille du canvas
  useEffect(() => {
    const el = scrollContainerRef.current;
    if (!el) return;
    const observer = new ResizeObserver(entries => {
      for (let entry of entries) {
        setViewportSize({ width: entry.contentRect.width, height: entry.contentRect.height });
      }
    });
    observer.observe(el);
    return () => observer.disconnect();
  }, []);

  const visibleTracks = useMemo(() => {
    return tracks.filter(t => t.id === 'instrumental' || t.id === 'track-rec-main' || t.type === TrackType.AUDIO || t.type === TrackType.MIDI || t.type === TrackType.BUS);
  }, [tracks]);

  // Calcul de la taille TOTALE virtuelle (pour le scrollbar)
  const totalContentWidth = useMemo(() => {
    const maxClipEnd = Math.max(...visibleTracks.flatMap(t => t.clips.map(c => c.start + c.duration)), 600); // Min 600s or clips
    return (maxClipEnd + 60) * zoomH;
  }, [visibleTracks, zoomH]);

  const totalArrangementHeight = useMemo(() => {
    let h = 40 + 500; // Header + min buffer
    visibleTracks.forEach(t => { h += zoomV; t.automationLanes.forEach(l => { if (l.isExpanded) h += 80; }); });
    return h;
  }, [visibleTracks, zoomV]);

  // Handle Track Context Menu
  const handleTrackContextMenu = (e: React.MouseEvent, trackId: string) => {
    e.preventDefault();
    setContextMenu({
      x: e.clientX,
      y: e.clientY,
      items: [
        { label: 'Duplicate Track', onClick: () => onDuplicateTrack?.(trackId), icon: 'fa-copy' },
        { label: 'Delete Track', danger: true, onClick: () => onDeleteTrack?.(trackId), icon: 'fa-trash' },
        { label: 'Freeze Track', onClick: () => onFreezeTrack?.(trackId), icon: 'fa-snowflake' }
      ]
    });
  };

  // --- LOGIQUE DE RENDU (WAVEFORM + FADES) ---
  const drawClip = (ctx: CanvasRenderingContext2D, clip: Clip, trackColor: string, x: number, y: number, w: number, h: number, isSelected: boolean) => {
    // Optimization: Skip draw if offscreen (using local x, w)
    if (x + w < 0 || x > ctx.canvas.width) return;

    // 1. Fond du clip
    ctx.save();
    ctx.fillStyle = '#1e2229';
    // Coins arrondis
    ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
    
    // Selection Highlight
    if (isSelected) {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.stroke();
    } else {
      ctx.strokeStyle = trackColor + '44';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    
    // Clip background tint
    ctx.fillStyle = trackColor + '15';
    ctx.fill();

    // 2. Waveform (Optimisée avec offset)
    if (clip.buffer) {
      const data = clip.buffer.getChannelData(0);
      const step = Math.ceil(data.length / (clip.buffer.duration * zoomH)); // Points par pixel
      const amp = h / 2;
      const centerY = y + h / 2;
      
      // Start index based on clip offset (Non-Destructive logic)
      const bufferStartIdx = Math.floor(clip.offset * clip.buffer.sampleRate);
      const bufferEndIdx = Math.floor((clip.offset + clip.duration) * clip.buffer.sampleRate);
      
      ctx.beginPath();
      ctx.strokeStyle = isSelected ? trackColor : trackColor + 'CC'; // Brighter if selected
      ctx.lineWidth = 1;

      // Dessin simplifié
      // Determine visible range of the clip to avoid drawing full waveform if clipped
      const clipVisibleStartPx = Math.max(0, -x);
      const clipVisibleEndPx = Math.min(w, ctx.canvas.width - x);
      
      for (let i = Math.floor(clipVisibleStartPx); i < Math.ceil(clipVisibleEndPx); i++) {
        const sampleIdx = bufferStartIdx + Math.floor(i * (clip.buffer.sampleRate / zoomH));
        if (sampleIdx >= bufferEndIdx || sampleIdx >= data.length) break;
        
        // Min/Max pour éviter l'aliasing
        let min = 1.0, max = -1.0;
        const windowSize = Math.floor(clip.buffer.sampleRate / zoomH);
        
        // Optim: check 10 points per pixel max
        const checkStep = Math.max(1, Math.floor(windowSize / 10));
        for (let j=0; j<windowSize; j+=checkStep) {
           const val = data[sampleIdx + j];
           if (val < min) min = val;
           if (val > max) max = val;
        }
        
        // Normalize gain
        const gain = clip.gain || 1.0;
        ctx.moveTo(x + i, centerY + min * amp * gain);
        ctx.lineTo(x + i, centerY + max * amp * gain);
      }
      ctx.stroke();
    }

    // 3. Dessin des Fades (Courbes)
    const fadeInPx = timeToPixels(clip.fadeIn);
    const fadeOutPx = timeToPixels(clip.fadeOut);

    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.globalAlpha = 0.7;

    // Fade In Curve
    if (clip.fadeIn > 0) {
      ctx.beginPath();
      ctx.moveTo(x, y + h); // Bottom Left
      // Bezier curve to top
      ctx.bezierCurveTo(x + fadeInPx * 0.5, y + h, x + fadeInPx * 0.5, y, x + fadeInPx, y);
      ctx.stroke();
      // Handle Dot
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(x + fadeInPx, y + 4, 3, 0, Math.PI * 2); ctx.fill();
    }

    // Fade Out Curve
    if (clip.fadeOut > 0) {
      ctx.beginPath();
      ctx.moveTo(x + w - fadeOutPx, y); // Top start of fade
      // Bezier to bottom right
      ctx.bezierCurveTo(x + w - fadeOutPx * 0.5, y, x + w - fadeOutPx * 0.5, y + h, x + w, y + h);
      ctx.stroke();
      // Handle Dot
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(x + w - fadeOutPx, y + 4, 3, 0, Math.PI * 2); ctx.fill();
    }

    // 4. Clip Name
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px Inter';
    ctx.fillText(clip.name, x + 5 + Math.max(0, fadeInPx - 10), y + 14);

    ctx.restore();
  };

  const drawTimeline = useCallback(() => {
    const canvas = canvasRef.current;
    const scroll = scrollContainerRef.current;
    if (!canvas || !scroll) return;
    
    // Virtual Canvas: We draw only what fits in the viewport
    // The canvas size is matched to viewportSize (set by ResizeObserver)
    if (canvas.width !== viewportSize.width || canvas.height !== viewportSize.height) {
        canvas.width = viewportSize.width;
        canvas.height = viewportSize.height;
    }

    const ctx = canvas.getContext('2d')!;
    const w = canvas.width;
    const h = canvas.height;
    const scrollX = scroll.scrollLeft;
    const scrollTop = scroll.scrollTop;

    ctx.clearRect(0, 0, w, h);

    // Fond
    ctx.fillStyle = '#0c0d10';
    ctx.fillRect(0, 0, w, h);

    // --- GRID RENDERING (Virtual) ---
    ctx.lineWidth = 1;
    const beatPx = (60 / bpm) * zoomH;
    
    // Determine visible time range
    const startTime = pixelsToTime(scrollX);
    const endTime = pixelsToTime(scrollX + w);
    
    // Draw Bar Lines
    // Start drawing from the first visible bar
    const startBar = Math.floor(startTime * (bpm / 60) / 4);
    const endBar = Math.ceil(endTime * (bpm / 60) / 4);

    for (let i = startBar; i <= endBar; i++) {
      const time = i * 4 * (60 / bpm);
      const x = timeToPixels(time) - scrollX; // Map to viewport
      
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
      
      // Beat Lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
      for(let j=1; j<4; j++) {
         const bx = x + j * beatPx;
         ctx.beginPath(); ctx.moveTo(bx, 0); ctx.lineTo(bx, h); ctx.stroke();
      }
    }

    // Loop Region (Virtual Coords)
    if (isLoopActive) {
      const lx = timeToPixels(loopStart) - scrollX;
      const lw = timeToPixels(loopEnd - loopStart);
      
      if (lx + lw > 0 && lx < w) {
          ctx.fillStyle = 'rgba(0, 242, 255, 0.03)';
          ctx.fillRect(lx, 40, lw, h); // 40 is header height offset if any
          ctx.strokeStyle = '#00f2ff';
          ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(lx, 0); ctx.lineTo(lx, h); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(lx + lw, 0); ctx.lineTo(lx + lw, h); ctx.stroke();
      }
    }

    // --- TRACKS RENDERING ---
    // Apply Vertical Scroll Offset
    ctx.save();
    ctx.translate(0, -scrollTop);

    let currentY = 40; // Top offset
    
    visibleTracks.forEach((track) => {
      const trackH = zoomV;
      
      // Only draw visible tracks
      if (currentY + trackH > scrollTop && currentY < scrollTop + h) {
          // Separator
          ctx.strokeStyle = '#1e2229';
          ctx.beginPath(); ctx.moveTo(0, currentY + trackH); ctx.lineTo(w, currentY + trackH); ctx.stroke();

          // Clips
          track.clips.forEach(clip => {
            const x = timeToPixels(clip.start) - scrollX;
            const width = timeToPixels(clip.duration);
            
            // Render Optimization: Only draw if visible
            if (x + width > 0 && x < w) {
                drawClip(ctx, clip, track.color, x, currentY + 2, width, trackH - 4, activeClip?.clip.id === clip.id);
            }
          });
          
          // Automation (Placeholder)
          track.automationLanes.forEach(lane => {
            if (lane.isExpanded) {
               ctx.fillStyle = '#111316';
               ctx.fillRect(0, currentY + zoomV, w, 80);
               // Draw curve...
            }
          });
      }

      currentY += trackH;
      track.automationLanes.forEach(l => { if (l.isExpanded) currentY += 80; });
    });
    
    ctx.restore(); // Undo vertical scroll translation

    // --- RULER & PLAYHEAD (Fixed on top) ---
    // Background for ruler
    ctx.fillStyle = '#14161a';
    ctx.fillRect(0, 0, w, 40);
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath(); ctx.moveTo(0, 40); ctx.lineTo(w, 40); ctx.stroke();

    // Draw Numbers
    ctx.fillStyle = '#64748b';
    ctx.font = 'bold 10px Inter';
    for (let i = startBar; i <= endBar; i++) {
        const time = i * 4 * (60 / bpm);
        const x = timeToPixels(time) - scrollX;
        if (x >= 0) ctx.fillText((i+1).toString(), x + 4, 24);
    }

    // Playhead
    const phX = timeToPixels(currentTime) - scrollX;
    if (phX >= 0 && phX <= w) {
      ctx.strokeStyle = isRecording ? '#ef4444' : '#00f2ff';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(phX, 0); ctx.lineTo(phX, h); ctx.stroke();
      ctx.fillStyle = isRecording ? '#ef4444' : '#00f2ff';
      ctx.beginPath(); ctx.moveTo(phX-5, 0); ctx.lineTo(phX+5, 0); ctx.lineTo(phX, 10); ctx.fill();
    }

    requestRef.current = requestAnimationFrame(drawTimeline);
  }, [visibleTracks, zoomV, zoomH, currentTime, isRecording, activeClip, isLoopActive, loopStart, loopEnd, bpm, viewportSize]);

  useEffect(() => {
    requestRef.current = requestAnimationFrame(drawTimeline);
    return () => cancelAnimationFrame(requestRef.current);
  }, [drawTimeline]);

  // --- UNIFIED POINTER HANDLER (MOUSE & TOUCH) ---
  const handlePointerDown = (clientX: number, clientY: number, button: number, shiftKey: boolean, target: EventTarget | null) => {
    if (!scrollContainerRef.current) return;

    const rect = scrollContainerRef.current.getBoundingClientRect();
    const scrollLeft = scrollContainerRef.current.scrollLeft;
    const scrollTop = scrollContainerRef.current.scrollTop;
    
    // Relative to viewport
    const viewportX = clientX - rect.left;
    const viewportY = clientY - rect.top;

    // Absolute Coords
    const absX = viewportX + scrollLeft;
    const absY = viewportY + scrollTop;
    
    const time = pixelsToTime(absX);

    // 1. Check Header (Seek / Loop)
    if (viewportY < 40) {
      if (button === 0) {
        if (shiftKey) {
           // Loop logic
        } else {
           setDragAction('SEEK');
           onSeek(applySnap(time, false));
        }
      }
      return;
    }

    // 2. Check Clips
    let currentY = 40;
    let foundClip = false;

    for (const t of visibleTracks) {
      const trackH = zoomV;
      // Check Y position taking scroll into account
      if (absY >= currentY && absY < currentY + trackH) {
        // We are on a track
        const clip = t.clips.find(c => time >= c.start && time <= c.start + c.duration);
        
        if (clip) {
          foundClip = true;
          if (button === 2) return;

          // Determine Zone (local coordinates inside clip)
          // Visual x of clip start = timeToPixels(clip.start) - scrollLeft
          // But here we need Logic X relative to clip start
          const clipStartPx = timeToPixels(clip.start);
          const clickRelX = absX - clipStartPx;
          const clickRelY = absY - currentY;

          const zone = getInteractionZone(clickRelX + clipStartPx, clickRelY, clip, zoomV); // Modified func to take absX? No, standard func logic reuse

          setDragStartX(absX);
          setInitialClipState({...clip}); // Clone
          setActiveClip({ trackId: t.id, clip });
          onSelectTrack(t.id);

          if (activeTool === 'SPLIT') {
             onEditClip?.(t.id, clip.id, 'SPLIT', { time: applySnap(time, shiftKey) });
             setDragAction('NONE');
          } else if (activeTool === 'ERASE') {
             onEditClip?.(t.id, clip.id, 'DELETE');
             setDragAction('NONE');
          } else {
             if (zone === 'RESIZE_L') setDragAction('TRIM_START');
             else if (zone === 'RESIZE_R') setDragAction('TRIM_END');
             else if (zone === 'FADE_IN') setDragAction('ADJUST_FADE_IN');
             else if (zone === 'FADE_OUT') setDragAction('ADJUST_FADE_OUT');
             else setDragAction('MOVE');
          }
          return;
        }
      }
      currentY += trackH;
      t.automationLanes.forEach(l => { if (l.isExpanded) currentY += 80; });
    }

    if (!foundClip && button === 0) {
      setActiveClip(null);
      setDragAction('SEEK');
      onSeek(applySnap(time, false));
    }
  };

  const handlePointerMove = (clientX: number, clientY: number, shiftKey: boolean) => {
    if (!scrollContainerRef.current) return;
    const rect = scrollContainerRef.current.getBoundingClientRect();
    const scrollLeft = scrollContainerRef.current.scrollLeft;
    const scrollTop = scrollContainerRef.current.scrollTop;
    
    const viewportX = clientX - rect.left;
    const viewportY = clientY - rect.top;
    const absX = viewportX + scrollLeft;
    const absY = viewportY + scrollTop;

    const currentTimeAtMouse = pixelsToTime(absX);
    
    setHoverTime(currentTimeAtMouse);
    setTooltipPos({ x: clientX, y: clientY - 30 });

    // --- CURSOR UPDATE (HOVER) ---
    if (dragAction === 'NONE') {
       let currentY = 40;
       let cursorSet = false;

       for (const t of visibleTracks) {
          if (absY >= currentY && absY < currentY + zoomV) {
             const clip = t.clips.find(c => currentTimeAtMouse >= c.start && currentTimeAtMouse <= c.start + c.duration);
             if (clip) {
                // To reuse getInteractionZone properly with absolute coords:
                // Pass absolute mouse X and relative Y
                const zone = getInteractionZone(absX, absY - currentY, clip, zoomV);
                document.body.style.cursor = activeTool === 'SPLIT' ? 'cell' : (activeTool === 'ERASE' ? 'not-allowed' : getCursorStyle(zone));
                cursorSet = true;
                break;
             }
          }
          currentY += zoomV;
          t.automationLanes.forEach(l => { if (l.isExpanded) currentY += 80; });
       }
       if (!cursorSet) document.body.style.cursor = 'default';
    }

    // --- DRAG ACTIONS ---
    else if (activeClip && initialClipState) {
       const deltaPx = absX - dragStartX;
       const deltaTime = pixelsToTime(deltaPx);
       const { trackId, clip } = activeClip;
       
       let newStart, newDuration, newOffset, newFadeIn, newFadeOut;

       switch (dragAction) {
          case 'MOVE':
             newStart = Math.max(0, applySnap(initialClipState.start + deltaTime, shiftKey));
             if (newStart !== clip.start) {
                onEditClip?.(trackId, clip.id, 'UPDATE_PROPS', { start: newStart });
             }
             break;

          case 'TRIM_START':
             const rawNewStart = applySnap(initialClipState.start + deltaTime, shiftKey);
             const maxStart = initialClipState.start + initialClipState.duration - 0.1;
             newStart = Math.min(Math.max(0, rawNewStart), maxStart);
             const diff = newStart - initialClipState.start;
             newDuration = initialClipState.duration - diff;
             newOffset = initialClipState.offset + diff;
             onEditClip?.(trackId, clip.id, 'UPDATE_PROPS', { start: newStart, duration: newDuration, offset: newOffset });
             break;

          case 'TRIM_END':
             let proposedDuration = initialClipState.duration + deltaTime;
             if (clip.buffer) {
                const maxDur = clip.buffer.duration - initialClipState.offset;
                proposedDuration = Math.min(proposedDuration, maxDur);
             }
             const proposedEnd = initialClipState.start + proposedDuration;
             const snappedEnd = applySnap(proposedEnd, shiftKey);
             newDuration = Math.max(0.1, snappedEnd - initialClipState.start);
             onEditClip?.(trackId, clip.id, 'UPDATE_PROPS', { duration: newDuration });
             break;

          case 'ADJUST_FADE_IN':
             const fInPos = currentTimeAtMouse - clip.start;
             newFadeIn = Math.max(0.001, Math.min(fInPos, clip.duration / 2));
             onEditClip?.(trackId, clip.id, 'UPDATE_PROPS', { fadeIn: newFadeIn });
             break;

          case 'ADJUST_FADE_OUT':
             const fOutPos = (clip.start + clip.duration) - currentTimeAtMouse;
             newFadeOut = Math.max(0.001, Math.min(fOutPos, clip.duration / 2));
             onEditClip?.(trackId, clip.id, 'UPDATE_PROPS', { fadeOut: newFadeOut });
             break;
             
          case 'SEEK':
             onSeek(Math.max(0, applySnap(currentTimeAtMouse, shiftKey)));
             break;
       }
    }
  };

  const handlePointerUp = () => {
    setDragAction('NONE');
    setInitialClipState(null);
    document.body.style.cursor = 'default';
  };

  // --- EVENT WRAPPERS ---
  const handleMouseDown = (e: React.MouseEvent) => handlePointerDown(e.clientX, e.clientY, e.button, e.shiftKey, e.target);
  const handleMouseMove = (e: React.MouseEvent) => handlePointerMove(e.clientX, e.clientY, e.shiftKey);
  const handleMouseUp = () => handlePointerUp();

  // --- TOUCH HANDLERS ---
  const handleTouchStart = (e: React.TouchEvent) => {
    const touch = e.touches[0];
    handlePointerDown(touch.clientX, touch.clientY, 0, false, e.target);
  };

  const handleTouchMove = (e: React.TouchEvent) => {
    if (dragAction !== 'NONE') e.preventDefault(); 
    const touch = e.touches[0];
    handlePointerMove(touch.clientX, touch.clientY, false);
  };

  const handleTouchEnd = (e: React.TouchEvent) => handlePointerUp();

  // Need to recreate this simple checker since we moved logic
  const getInteractionZone = (absX: number, relY: number, clip: Clip, clipHeight: number): InteractionZone => {
    const clipStartPx = timeToPixels(clip.start);
    const localX = absX - clipStartPx; // Coordinate inside clip
    const w = timeToPixels(clip.duration);

    const EDGE_THRESHOLD = 20; 
    const FADE_HANDLE_SIZE = 25; 

    // Check Top Corners for Fades
    if (relY < 30) { 
        if (localX < FADE_HANDLE_SIZE + timeToPixels(clip.fadeIn)) return 'FADE_IN';
        if (localX > w - FADE_HANDLE_SIZE - timeToPixels(clip.fadeOut)) return 'FADE_OUT';
    }

    // Check Bottom Corners for Resize
    if (relY > clipHeight / 2) {
        if (localX < EDGE_THRESHOLD) return 'RESIZE_L';
        if (localX > w - EDGE_THRESHOLD) return 'RESIZE_R';
    }

    return 'BODY';
  };

  const getCursorStyle = (zone: InteractionZone): string => {
    switch (zone) {
      case 'RESIZE_L': return 'w-resize';
      case 'RESIZE_R': return 'e-resize';
      case 'FADE_IN': case 'FADE_OUT': return 'crosshair';
      case 'BODY': return activeTool === 'SPLIT' ? 'text' : 'move';
      default: return 'default';
    }
  };

  const applySnap = (time: number, isShiftPressed: boolean) => {
    if (isShiftPressed || !snapEnabled) return time;
    const beatDuration = 60 / bpm;
    const subDivision = beatDuration / 4; 
    return Math.round(time / subDivision) * subDivision;
  };

  return (
    <div className="flex-1 flex flex-col overflow-hidden bg-[#0c0d10] relative select-none" onContextMenu={(e) => e.preventDefault()}>
      {/* Header Controls */}
      <div className="h-12 bg-[#14161a] border-b border-white/5 flex items-center px-4 justify-between z-30 shrink-0">
        <div className="flex items-center space-x-6">
          <div className="flex bg-black/40 rounded-lg p-0.5 border border-white/5">
            <button onClick={() => setActiveTool('SELECT')} className={\`w-8 h-8 rounded-md flex items-center justify-center transition-all \${activeTool === 'SELECT' ? 'bg-cyan-500 text-black' : 'text-slate-500 hover:text-white'}\`} title="Smart Tool (1)">
              <i className="fas fa-mouse-pointer text-[10px]"></i>
            </button>
            <button onClick={() => setActiveTool('SPLIT')} className={\`w-8 h-8 rounded-md flex items-center justify-center transition-all \${activeTool === 'SPLIT' ? 'bg-cyan-500 text-black' : 'text-slate-500 hover:text-white'}\`} title="Split Tool (2)">
              <i className="fas fa-cut text-[10px]"></i>
            </button>
            <button onClick={() => setActiveTool('ERASE')} className={\`w-8 h-8 rounded-md flex items-center justify-center transition-all \${activeTool === 'ERASE' ? 'bg-red-500 text-white' : 'text-slate-500 hover:text-white'}\`} title="Erase Tool (3)">
              <i className="fas fa-eraser text-[10px]"></i>
            </button>
          </div>
          <button onClick={() => setSnapEnabled(!snapEnabled)} className={\`px-4 py-2 rounded-xl border transition-all text-[9px] font-black uppercase tracking-widest \${snapEnabled ? 'bg-cyan-500/10 border-cyan-500/30 text-cyan-400' : 'bg-white/5 border-white/10 text-slate-500'}\`}>
            <i className="fas fa-magnet mr-2"></i> {snapEnabled ? 'Snap ON' : 'Snap OFF'}
          </button>
        </div>

        <div className="flex items-center space-x-8">
          <div className="flex items-center space-x-3">
             <i className="fas fa-search-plus text-[10px] text-slate-600"></i>
             <input type="range" min="10" max="300" step="1" value={zoomH} onChange={(e) => setZoomH(parseInt(e.target.value))} className="w-24 accent-cyan-500 h-1 bg-white/5 rounded-full" />
          </div>
        </div>
      </div>

      <div className="flex-1 flex overflow-hidden relative">
        {/* Track Headers (Left Sidebar) */}
        <div className="w-64 flex-shrink-0 border-r border-white/5 bg-[#14161a] z-40 flex flex-col overflow-y-auto no-scrollbar pt-10">
          {visibleTracks.map((track) => (
            <div key={track.id} style={{ height: \`\${zoomV}px\`, flexShrink: 0 }}>
              <TrackHeader 
                track={track} isSelected={selectedTrackId === track.id} onSelect={() => onSelectTrack(track.id)} onUpdate={onUpdateTrack} 
                onDropPlugin={onDropPluginOnTrack} onMovePlugin={onMovePlugin} onSelectPlugin={onSelectPlugin} onRemovePlugin={onRemovePlugin} 
                onRequestAddPlugin={onRequestAddPlugin} onContextMenu={handleTrackContextMenu}
                onDragStartTrack={() => {}} onDragOverTrack={() => {}} onDropTrack={() => {}} 
              />
              {track.automationLanes.map(l => l.isExpanded && <div key={l.id} style={{ height: '80px' }} className="border-b border-white/5 bg-[#0f1115]"></div>)}
            </div>
          ))}
        </div>

        {/* Timeline Canvas Container (Virtual Scroll) */}
        <div 
          ref={scrollContainerRef} 
          className="flex-1 overflow-auto relative custom-scroll scroll-smooth touch-pan-x touch-pan-y" 
          onMouseDown={handleMouseDown} 
          onMouseMove={handleMouseMove} 
          onMouseUp={handleMouseUp}
          onMouseLeave={handleMouseUp}
          onTouchStart={handleTouchStart}
          onTouchMove={handleTouchMove}
          onTouchEnd={handleTouchEnd}
        >
          {/* Spacer Div to force scrollbar based on content size */}
          <div style={{ width: totalContentWidth, height: totalArrangementHeight }} className="absolute top-0 left-0 pointer-events-none" />
          
          {/* Sticky Canvas (matches viewport size) */}
          <canvas 
            ref={canvasRef} 
            className="sticky top-0 left-0"
            style={{ display: 'block' }}
          />
        </div>
      </div>

      {/* Overlays */}
      {contextMenu && <ContextMenu x={contextMenu.x} y={contextMenu.y} items={contextMenu.items} onClose={() => setContextMenu(null)} />}
      {hoverTime !== null && dragAction !== 'NONE' && (
        <div className="fixed z-[200] px-3 py-1.5 bg-black/90 border border-cyan-500/30 rounded-lg shadow-2xl pointer-events-none text-[10px] font-black text-cyan-400 font-mono" style={{ left: tooltipPos.x + 15, top: tooltipPos.y }}>
           {hoverTime.toFixed(3)}s
           {dragAction !== 'NONE' && <span className="ml-2 text-white opacity-50">[{dragAction}]</span>}
        </div>
      )}
    </div>
  );
};
export default ArrangementView;` },
{ path: "components/MixerView.tsx", content: `
import React, { useRef, useEffect, useState } from 'react';
import { Track, TrackType, PluginInstance, TrackSend, PluginType } from '../types';
import { audioEngine } from '../engine/AudioEngine';

const VUMeter: React.FC<{ analyzer: AnalyserNode | null }> = ({ analyzer }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  useEffect(() => {
    if (!analyzer) return;
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d')!;
    const data = new Uint8Array(analyzer.frequencyBinCount);
    let frame: number;
    const draw = () => {
      analyzer.getByteFrequencyData(data);
      let sum = 0; for (let i = 0; i < data.length; i++) sum += data[i];
      const level = Math.min(1, (sum / data.length / 128) * 1.5);
      const w = canvas.width; const h = canvas.height;
      ctx.clearRect(0, 0, w, h); ctx.fillStyle = '#1e2229'; ctx.fillRect(0, 0, w, h);
      const grad = ctx.createLinearGradient(0, h, 0, 0);
      grad.addColorStop(0, '#22c55e'); grad.addColorStop(0.7, '#eab308'); grad.addColorStop(0.9, '#ef4444');
      ctx.fillStyle = grad; ctx.fillRect(0, h - (level * h), w, level * h);
      frame = requestAnimationFrame(draw);
    };
    draw(); return () => cancelAnimationFrame(frame);
  }, [analyzer]);
  return <canvas ref={canvasRef} width={6} height={120} className="rounded-full overflow-hidden" />;
};

const SendKnob: React.FC<{ send: TrackSend, track: Track, onUpdate: (t: Track) => void }> = ({ send, track, onUpdate }) => {
  // Logic unifiée pour Souris et Tactile
  const handleInteraction = (clientY: number, startY: number, startLevel: number) => {
      const delta = (startY - clientY) / 100;
      const newLevel = Math.max(0, Math.min(1.5, startLevel + delta));
      const newSends = track.sends.map(s => s.id === send.id ? { ...s, level: newLevel } : s);
      onUpdate({ ...track, sends: newSends });
  };

  const onMouseDown = (e: React.MouseEvent) => {
    e.preventDefault(); e.stopPropagation();
    const startY = e.clientY; const startLevel = send.level;
    const move = (m: MouseEvent) => handleInteraction(m.clientY, startY, startLevel);
    const up = () => { window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', up); };
    window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
  };

  const onTouchStart = (e: React.TouchEvent) => {
    e.stopPropagation();
    const startY = e.touches[0].clientY; const startLevel = send.level;
    // On utilise l'événement move local
    // TODO: pour un drag continu hors de l'élément, c'est plus complexe en React pur sans ref globale,
    // mais pour un knob c'est souvent ok de garder le doigt dessus.
  };

  const onTouchMove = (e: React.TouchEvent) => {
      // Pour simplifier sans "startY" stocké, on utilise le mouvement relatif ou on stocke startY dans un ref si besoin.
      // Ici version simplifiée : step-based ou on suppose un start lors du touchstart.
      // Le pattern propre React sans ref est dur. On va utiliser le ref pattern classique.
  };
  
  // Ref-based touch handler pattern for functional components
  const startYRef = useRef(0);
  const startLevelRef = useRef(0);

  const handleTouchStart = (e: React.TouchEvent) => {
      e.stopPropagation();
      startYRef.current = e.touches[0].clientY;
      startLevelRef.current = send.level;
  };

  const handleTouchMove = (e: React.TouchEvent) => {
      handleInteraction(e.touches[0].clientY, startYRef.current, startLevelRef.current);
  };

  const getSendColor = (id: string) => {
    if (id === 'send-delay') return '#00f2ff';
    if (id === 'send-verb-short') return '#6366f1';
    return '#a855f7';
  };

  return (
    <div className="flex flex-col items-center group/send touch-none">
      <div 
        onMouseDown={onMouseDown}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        className="w-5 h-5 rounded-full bg-black border border-white/10 flex items-center justify-center cursor-ns-resize hover:border-white/30 transition-all"
      >
        <div className="w-0.5 h-2.5 rounded-full" style={{ backgroundColor: getSendColor(send.id), transform: \`rotate(\${(send.level / 1.5) * 270 - 135}deg) translateY(-0.5px)\` }} />
      </div>
      <span className="text-[5px] font-black text-slate-600 uppercase mt-0.5">{send.id.replace('send-', '').toUpperCase()}</span>
    </div>
  );
};

const ChannelStrip: React.FC<{ 
  track: Track, 
  onUpdate: (t: Track) => void, 
  isMaster?: boolean, 
  onOpenPlugin?: (trackId: string, p: PluginInstance) => void,
  onToggleBypass?: (trackId: string, pluginId: string) => void,
  onRemovePlugin?: (trackId: string, pluginId: string) => void,
  onDropPlugin?: (trackId: string, type: PluginType) => void,
  onRequestAddPlugin?: (trackId: string, x: number, y: number) => void
}> = ({ track, onUpdate, isMaster = false, onOpenPlugin, onToggleBypass, onRemovePlugin, onDropPlugin, onRequestAddPlugin }) => {
  const [isDragOver, setIsDragOver] = useState(false);
  const faderTrackRef = useRef<HTMLDivElement>(null);
  const analyzer = isMaster ? audioEngine.getMasterAnalyzer() : audioEngine.getTrackAnalyzer(track.id);

  const handleFXClick = (e: React.MouseEvent | React.TouchEvent, p: PluginInstance) => {
    e.stopPropagation();
    onOpenPlugin?.(track.id, p);
  };

  const handleEmptySlotClick = (e: React.MouseEvent | React.TouchEvent) => {
    e.stopPropagation();
    let clientX = 0;
    let clientY = 0;
    if ('touches' in e) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = (e as React.MouseEvent).clientX;
      clientY = (e as React.MouseEvent).clientY;
    }
    if (onRequestAddPlugin) onRequestAddPlugin(track.id, clientX, clientY);
  };

  // Logic Volume Interaction
  const handleVolInteraction = (clientY: number, rect: DOMRect) => {
      const p = 1 - Math.max(0, Math.min(1, (clientY - rect.top) / rect.height));
      onUpdate({...track, volume: p * p * 1.5});
  };

  const onVolMouseDown = (e: React.MouseEvent) => {
      const rect = faderTrackRef.current!.getBoundingClientRect();
      handleVolInteraction(e.clientY, rect);
      const move = (m: MouseEvent) => handleVolInteraction(m.clientY, rect);
      const up = () => { window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', up); };
      window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
  };

  const onVolTouchStart = (e: React.TouchEvent) => {
      e.stopPropagation(); // Empêche le scroll
      const rect = faderTrackRef.current!.getBoundingClientRect();
      handleVolInteraction(e.touches[0].clientY, rect);
  };

  const onVolTouchMove = (e: React.TouchEvent) => {
      const rect = faderTrackRef.current!.getBoundingClientRect();
      handleVolInteraction(e.touches[0].clientY, rect);
  };

  // Logic Pan Interaction (Knob pattern)
  const panStartY = useRef(0);
  const panStartVal = useRef(0);

  const handlePanMove = (clientY: number) => {
      const d = (panStartY.current - clientY)/100;
      onUpdate({...track, pan: Math.max(-1, Math.min(1, panStartVal.current + d))});
  };

  const onPanTouchStart = (e: React.TouchEvent) => {
      e.stopPropagation();
      panStartY.current = e.touches[0].clientY;
      panStartVal.current = track.pan;
  };

  const onPanTouchMove = (e: React.TouchEvent) => {
      handlePanMove(e.touches[0].clientY);
  };

  return (
    <div 
      onDragOver={(e) => { e.preventDefault(); setIsDragOver(true); e.dataTransfer.dropEffect = 'copy'; }}
      onDragLeave={() => setIsDragOver(false)}
      onDrop={(e) => { 
        e.preventDefault(); 
        setIsDragOver(false); 
        const type = e.dataTransfer.getData('pluginType') as PluginType;
        if (type && onDropPlugin) onDropPlugin(track.id, type);
      }}
      className={\`flex-shrink-0 bg-[#0c0e12] border-r border-white/5 flex flex-col h-full transition-all touch-manipulation \${isMaster ? 'w-56 border-l-2 border-cyan-500/20' : track.type === TrackType.BUS ? 'w-44 bg-[#14161a]' : 'w-36'} \${isDragOver ? 'bg-cyan-500/5' : ''}\`}
    >
      
      {!isMaster && track.type === TrackType.AUDIO && (
        <div className="h-14 bg-black/40 border-b border-white/5 p-2 grid grid-cols-3 gap-1">
          {track.sends.map(s => <SendKnob key={s.id} send={s} track={track} onUpdate={onUpdate} />)}
        </div>
      )}
      
      <div className={\`\${track.type === TrackType.BUS ? 'h-48' : 'h-40'} bg-black/20 border-b border-white/5 p-2 space-y-1 overflow-y-auto custom-scroll\`}>
        <span className="text-[7px] font-black text-slate-600 uppercase px-1 mb-1 block">{track.type === TrackType.BUS ? 'Bus Inserts' : 'Inserts'}</span>
        {track.plugins.map(p => (
          <div key={p.id} className="relative group/fxslot w-full h-6 mb-1 fx-slot">
            <button 
              onClick={(e) => handleFXClick(e, p)}
              onTouchStart={(e) => handleFXClick(e, p)}
              className={\`w-full h-full bg-black/40 rounded border border-white/5 text-[8px] font-black hover:border-cyan-500/40 transition-all px-2 text-left truncate flex items-center pr-12 \${p.isEnabled ? 'text-cyan-400' : 'text-slate-600'}\`}
            >
               {p.type}
            </button>
            
            <div className="absolute right-1 top-0 bottom-0 flex items-center space-x-1">
               <button 
                onClick={(e) => { e.stopPropagation(); onToggleBypass?.(track.id, p.id); }}
                onTouchStart={(e) => { e.stopPropagation(); onToggleBypass?.(track.id, p.id); }}
                className={\`w-4 h-4 rounded flex items-center justify-center transition-all \${p.isEnabled ? 'bg-cyan-500/20 text-cyan-400' : 'bg-white/5 text-slate-600'}\`}
               >
                 <i className="fas fa-power-off text-[6px]"></i>
               </button>
            </div>

            <button 
              onClick={(e) => { e.stopPropagation(); onRemovePlugin?.(track.id, p.id); }}
              onTouchStart={(e) => { e.stopPropagation(); onRemovePlugin?.(track.id, p.id); }}
              className="delete-fx"
            >
              <i className="fas fa-times"></i>
            </button>
          </div>
        ))}
        {Array.from({ length: Math.max(0, 4 - track.plugins.length) }).map((_, i) => (
           <button 
            key={i} 
            onClick={handleEmptySlotClick}
            onTouchStart={handleEmptySlotClick}
            className="w-full h-6 rounded border border-dashed border-white/10 bg-black/5 flex items-center justify-center opacity-20 hover:opacity-100 hover:border-cyan-500/40 transition-all"
           >
             <i className="fas fa-plus text-[6px]"></i>
           </button>
        ))}
      </div>

      <div className="flex-1 p-3 flex flex-col">
        <div className="mb-4 flex flex-col items-center">
           <div 
            onMouseDown={(e) => {
              const startY = e.clientY; const startPan = track.pan;
              const move = (m: MouseEvent) => { const d = (startY-m.clientY)/100; onUpdate({...track, pan: Math.max(-1, Math.min(1, startPan+d))}); };
              const up = () => { window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', up); };
              window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
            }}
            onTouchStart={onPanTouchStart}
            onTouchMove={onPanTouchMove}
            className="w-7 h-7 rounded-full bg-black border border-white/10 flex items-center justify-center cursor-ns-resize shadow-xl touch-none"
           >
              <div className="w-0.5 h-3 bg-cyan-500 rounded-full" style={{ transform: \`rotate(\${track.pan * 140}deg) translateY(-1px)\` }} />
           </div>
        </div>

        <div className="flex-1 flex space-x-2">
           <div className="flex-1 relative flex flex-col items-center">
              <div 
                ref={faderTrackRef} 
                onMouseDown={onVolMouseDown}
                onTouchStart={onVolTouchStart}
                onTouchMove={onVolTouchMove}
                className="w-5 h-full bg-black/40 rounded-full border border-white/5 relative cursor-pointer touch-none"
              >
                 <div className={\`absolute left-1/2 -translate-x-1/2 rounded border border-white/20 shadow-2xl z-20 flex items-center justify-center \${track.type === TrackType.BUS ? 'w-8 h-12 bg-amber-500 border-amber-400' : 'w-7 h-10 bg-[#1e2229]'}\`} style={{ bottom: \`calc(\${(Math.sqrt(track.volume / 1.5))*100}% - 20px)\` }}>
                    <div className={\`w-full h-0.5 \${track.type === TrackType.BUS ? 'bg-black' : 'bg-cyan-500'}\`} />
                 </div>
              </div>
           </div>
           <div className="flex space-x-1">
              <VUMeter analyzer={analyzer} />
              <VUMeter analyzer={analyzer} />
           </div>
        </div>

        <div className="mt-4 flex space-x-1">
           <button onClick={() => onUpdate({...track, isMuted: !track.isMuted})} onTouchStart={() => onUpdate({...track, isMuted: !track.isMuted})} className={\`flex-1 h-6 rounded text-[7px] font-black border \${track.isMuted ? 'bg-amber-500 text-black border-amber-400' : 'bg-white/5 border-white/5 text-slate-600'}\`}>MUTE</button>
           <button onClick={() => onUpdate({...track, isSolo: !track.isSolo})} onTouchStart={() => onUpdate({...track, isSolo: !track.isSolo})} className={\`flex-1 h-6 rounded text-[7px] font-black border \${track.isSolo ? 'bg-cyan-500 text-black border-cyan-400' : 'bg-white/5 border-white/5 text-slate-600'}\`}>SOLO</button>
        </div>
        
        <div className={\`mt-3 h-10 rounded-lg flex items-center px-2 text-[8px] font-black uppercase border truncate relative \${track.type === TrackType.BUS ? 'bg-amber-500/10 border-amber-500/30 text-amber-400' : 'bg-black/40 border-white/10 text-white'}\`}>
           <div className="w-1 h-full mr-2 rounded-full" style={{ backgroundColor: track.color }} />
           <span className="truncate">{track.name}</span>
        </div>
      </div>
    </div>
  );
};

const MixerView: React.FC<{ 
  tracks: Track[], 
  onUpdateTrack: (t: Track) => void, 
  onOpenPlugin?: (tid: string, p: PluginInstance) => void,
  onToggleBypass?: (tid: string, pid: string) => void,
  onRemovePlugin?: (tid: string, pid: string) => void,
  onDropPluginOnTrack?: (tid: string, type: PluginType) => void,
  onRequestAddPlugin?: (tid: string, x: number, y: number) => void
}> = ({ tracks, onUpdateTrack, onOpenPlugin, onToggleBypass, onRemovePlugin, onDropPluginOnTrack, onRequestAddPlugin }) => {
  const audioTracks = tracks.filter(t => t.type === TrackType.AUDIO);
  const busTracks = tracks.filter(t => t.type === TrackType.BUS && t.id !== 'master');
  const sendTracks = tracks.filter(t => t.type === TrackType.SEND);
  const masterTrack = tracks.find(t => t.id === 'master');

  return (
    <div className="flex-1 flex overflow-x-auto bg-[#08090b] custom-scroll h-full snap-x snap-mandatory">
      {audioTracks.map(t => <div key={t.id} className="snap-start"><ChannelStrip track={t} onUpdate={onUpdateTrack} onOpenPlugin={onOpenPlugin} onToggleBypass={onToggleBypass} onRemovePlugin={onRemovePlugin} onDropPlugin={onDropPluginOnTrack} onRequestAddPlugin={onRequestAddPlugin} /></div>)}
      {busTracks.length > 0 && <div className="w-2 bg-gradient-to-r from-black to-amber-500/5 snap-start" />}
      {busTracks.map(t => <div key={t.id} className="snap-start"><ChannelStrip track={t} onUpdate={onUpdateTrack} onOpenPlugin={onOpenPlugin} onToggleBypass={onToggleBypass} onRemovePlugin={onRemovePlugin} onDropPlugin={onDropPluginOnTrack} onRequestAddPlugin={onRequestAddPlugin} /></div>)}
      <div className="w-4 bg-black/30 border-r border-white/5" />
      {sendTracks.map(t => <div key={t.id} className="snap-start"><ChannelStrip track={t} onUpdate={onUpdateTrack} onOpenPlugin={onOpenPlugin} onToggleBypass={onToggleBypass} onRemovePlugin={onRemovePlugin} onDropPlugin={onDropPluginOnTrack} onRequestAddPlugin={onRequestAddPlugin} /></div>)}
      <div className="w-10 bg-black/50 border-r border-white/5" />
      <div className="snap-start"><ChannelStrip track={masterTrack || { id: 'master', name: 'MASTER BUS', type: TrackType.BUS, color: '#00f2ff', isMuted: false, isSolo: false, isTrackArmed: false, isFrozen: false, volume: 1.0, pan: 0, outputTrackId: '', sends: [], clips: [], plugins: [], automationLanes: [], totalLatency: 0 }} onUpdate={() => {}} isMaster={true} onOpenPlugin={onOpenPlugin} onToggleBypass={onToggleBypass} onRemovePlugin={onRemovePlugin} onDropPlugin={onDropPluginOnTrack} onRequestAddPlugin={onRequestAddPlugin} /></div>
    </div>
  );
};
export default MixerView;` },
{ path: "components/PianoRoll.tsx", content: `
import React from 'react';

const PianoRoll: React.FC = () => {
  const keys = ['B', 'A#', 'A', 'G#', 'G', 'F#', 'F', 'E', 'D#', 'D', 'C#', 'C'];
  const octaves = [4, 3, 2];
  
  return (
    <div className="flex-1 flex flex-col overflow-hidden bg-[#050608] border-t border-white/5">
       <div className="h-12 bg-[#0c0e12]/80 backdrop-blur-md border-b border-white/5 flex items-center px-6 space-x-8">
          <div className="flex items-center space-x-2">
            <div className="w-8 h-8 rounded-xl bg-cyan-500/10 flex items-center justify-center text-cyan-400 border border-cyan-500/20">
               <i className="fas fa-keyboard text-xs"></i>
            </div>
            <span className="text-[10px] font-black text-white uppercase tracking-widest">Neural Sequencer</span>
          </div>

          <div className="flex space-x-1.5">
            <button className="w-9 h-9 rounded-xl bg-white/5 text-slate-400 hover:text-cyan-400 hover:bg-white/10 transition-all flex items-center justify-center border border-white/5"><i className="fas fa-pencil-alt text-[10px]"></i></button>
            <button className="w-9 h-9 rounded-xl bg-white/5 text-slate-400 hover:text-red-400 hover:bg-white/10 transition-all flex items-center justify-center border border-white/5"><i className="fas fa-eraser text-[10px]"></i></button>
            <button className="w-9 h-9 rounded-xl bg-white/5 text-slate-400 hover:text-white hover:bg-white/10 transition-all flex items-center justify-center border border-white/5"><i className="fas fa-expand-arrows-alt text-[10px]"></i></button>
          </div>
          
          <div className="h-4 w-px bg-white/10"></div>
          
          <div className="flex items-center space-x-4">
             <div className="flex flex-col">
                <span className="text-[7px] font-black text-slate-600 uppercase">Quantization</span>
                <span className="text-[9px] font-black text-cyan-500 uppercase">1/16 Step</span>
             </div>
             <div className="flex flex-col">
                <span className="text-[7px] font-black text-slate-600 uppercase">Snap Mode</span>
                <span className="text-[9px] font-black text-green-500 uppercase">Active</span>
             </div>
          </div>
       </div>

       <div className="flex-1 flex overflow-hidden">
          {/* Keybed */}
          <div className="w-20 bg-[#0c0e12] border-r border-white/5 overflow-y-auto overflow-x-hidden flex flex-col scrollbar-hide">
            {octaves.map(oct => (
              <React.Fragment key={oct}>
                {keys.map(k => (
                  <div 
                    key={\`\${k}\${oct}\`} 
                    className={\`h-8 border-b border-white/[0.03] flex items-center justify-end px-3 text-[9px] font-black transition-colors \${k.includes('#') ? 'bg-black text-slate-700' : 'bg-slate-300 text-black hover:bg-white'}\`}
                  >
                    {k === 'C' ? <span className="opacity-40">{k}{oct}</span> : <span className="opacity-20">{k}</span>}
                  </div>
                ))}
              </React.Fragment>
            ))}
          </div>

          {/* Note Grid */}
          <div className="flex-1 overflow-auto relative bg-[#08090b] scrollbar-hide">
             {/* Cyber Grid Pattern */}
             <div className="absolute inset-0 grid grid-cols-[repeat(64,minmax(40px,1fr))] grid-rows-[repeat(36,32px)] opacity-[0.03]">
                {[...Array(64 * 36)].map((_, i) => (
                  <div key={i} className="border-r border-b border-white"></div>
                ))}
             </div>

             <div className="absolute inset-0 grid grid-cols-[repeat(16,minmax(160px,1fr))] pointer-events-none">
                {[...Array(16)].map((_, i) => (
                  <div key={i} className="border-r border-cyan-500/10 h-full"></div>
                ))}
             </div>
             
             {/* Futuristic MIDI notes */}
             <div className="absolute h-6 bg-cyan-500 glow-cyan rounded-lg border border-white/20 shadow-[0_0_15px_rgba(6,182,212,0.4)] flex items-center px-2" style={{ left: '80px', top: '160px', width: '120px' }}>
                <div className="w-1 h-3 bg-white/40 rounded-full mr-2"></div>
                <span className="text-[8px] font-black text-black/60 uppercase">C4 Lead</span>
             </div>
             
             <div className="absolute h-6 bg-cyan-500 glow-cyan rounded-lg border border-white/20 shadow-[0_0_15px_rgba(6,182,212,0.4)]" style={{ left: '240px', top: '192px', width: '40px' }}></div>
             <div className="absolute h-6 bg-cyan-500 glow-cyan rounded-lg border border-white/20 shadow-[0_0_15px_rgba(6,182,212,0.4)]" style={{ left: '280px', top: '224px', width: '80px' }}></div>
             
             <div className="absolute h-6 bg-purple-500 glow-purple rounded-lg border border-white/20 shadow-[0_0_15px_rgba(139,92,246,0.4)]" style={{ left: '400px', top: '128px', width: '160px' }}></div>
          </div>
       </div>

       {/* Velocity Lane */}
       <div className="h-32 bg-[#0c0e12] border-t border-white/10 p-4">
          <div className="flex justify-between items-center mb-4">
            <span className="text-[9px] text-slate-600 font-black uppercase tracking-widest">Velocity Modulation</span>
            <span className="text-[8px] font-mono text-cyan-500/40">CC #01 - DYNAMICS</span>
          </div>
          <div className="flex items-end space-x-2 h-16 px-20">
             {[80, 70, 95, 60, 85, 40, 90, 75].map((h, i) => (
               <div key={i} className="w-1.5 rounded-full bg-gradient-to-t from-cyan-900 to-cyan-400 glow-cyan transition-all hover:scale-x-150" style={{ height: \`\${h}%\` }}></div>
             ))}
          </div>
       </div>
    </div>
  );
};

export default PianoRoll;` },
{ path: "components/SideBrowser.tsx", content: `
import React, { useState, useRef, useEffect, useMemo } from 'react';
import { PluginType } from '../types';

interface SideBrowserProps {
  onLocalImport?: (file: File) => void;
  activeTabOverride?: 'local' | 'fx';
  onTabChange?: (tab: 'local' | 'fx') => void;
  onAddPlugin?: (type: string) => void;
  shouldFocusSearch?: boolean;
  onSearchFocused?: () => void;
}

const SideBrowser: React.FC<SideBrowserProps> = ({ 
  onLocalImport, 
  activeTabOverride, 
  onTabChange,
  onAddPlugin,
  shouldFocusSearch,
  onSearchFocused
}) => {
  const [internalTab, setInternalTab] = useState<'local' | 'fx'>('local');
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedIndex, setSelectedIndex] = useState(0);
  
  const activeTab = activeTabOverride || internalTab;
  const searchInputRef = useRef<HTMLInputElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const AVAILABLE_FX = [
    { id: 'MASTERSYNC', name: 'Master Sync', desc: 'Auto-Analysis & Scaling', icon: 'fa-sync-alt', color: '#00f2ff' },
    { id: 'VOCALSATURATOR', name: 'Vocal Saturator', desc: 'Analog Warmth & Drive', icon: 'fa-fire', color: '#10b981' },
    { id: 'PROEQ12', name: 'Pro-EQ 12', desc: '12-Band Surgical EQ', icon: 'fa-wave-square', color: '#00f2ff' },
    { id: 'AUTOTUNE', name: 'Auto-Tune Pro', desc: 'Neural Pitch Correction', icon: 'fa-microphone-alt', color: '#00f2ff' },
    { id: 'DENOISER', name: 'Denoiser', desc: 'Noise Suppression', icon: 'fa-broom', color: '#00ff88' },
    { id: 'COMPRESSOR', name: 'Leveler', desc: 'Dynamics Processor', icon: 'fa-compress-alt', color: '#f97316' },
    { id: 'REVERB', name: 'Spatial Verb', desc: 'Hybrid Reverb', icon: 'fa-mountain-sun', color: '#6366f1' },
    { id: 'DELAY', name: 'Sync Delay', desc: 'Tempo Echo', icon: 'fa-history', color: '#0ea5e9' },
    { id: 'CHORUS', name: 'Vocal Chorus', desc: 'Stereo Widener', icon: 'fa-layer-group', color: '#a855f7' },
    { id: 'FLANGER', name: 'Studio Flanger', desc: 'Jet Modulation', icon: 'fa-wind', color: '#3b82f6' },
    { id: 'DOUBLER', name: 'Vocal Doubler', desc: 'Haas Image Doubling', icon: 'fa-people-arrows', color: '#8b5cf6' },
    { id: 'STEREOSPREADER', name: 'Phase Guard', desc: 'M/S Width Spreader', icon: 'fa-arrows-alt-h', color: '#06b6d4' },
    { id: 'DEESSER', name: 'S-Killer', desc: 'Sibilance Processor', icon: 'fa-scissors', color: '#ef4444' }
  ];

  const sortedFX = useMemo(() => {
    return [...AVAILABLE_FX].sort((a, b) => a.name.localeCompare(b.name));
  }, []);

  const filteredFX = useMemo(() => {
    const list = sortedFX.filter(fx => 
      fx.name.toLowerCase().includes(searchTerm.toLowerCase()) || 
      fx.desc.toLowerCase().includes(searchTerm.toLowerCase())
    );
    setSelectedIndex(0); 
    return list;
  }, [searchTerm, sortedFX]);

  useEffect(() => {
    if (activeTab === 'fx' || shouldFocusSearch) {
      searchInputRef.current?.focus();
      if (shouldFocusSearch && onSearchFocused) onSearchFocused();
    }
  }, [activeTab, shouldFocusSearch]);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (activeTab !== 'fx' || filteredFX.length === 0) return;
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      setSelectedIndex(prev => (prev + 1) % filteredFX.length);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      setSelectedIndex(prev => (prev - 1 + filteredFX.length) % filteredFX.length);
    } else if (e.key === 'Enter') {
      e.preventDefault();
      const selected = filteredFX[selectedIndex];
      if (selected) handleAddPlugin(selected.id);
    } else if (e.key === 'Escape') {
      setSearchTerm('');
    }
  };

  const setActiveTab = (tab: 'local' | 'fx') => {
    if (onTabChange) onTabChange(tab);
    setInternalTab(tab);
  };

  const handleDragStart = (e: React.DragEvent, type: string) => {
    e.dataTransfer.setData('pluginType', type);
    e.dataTransfer.dropEffect = 'copy';
  };

  const handleAddPlugin = (type: string) => {
    if (onAddPlugin) {
      onAddPlugin(type);
      setSearchTerm(''); 
    }
  };

  return (
    <div className="flex flex-col h-full bg-[#08090b] border-r border-white/5 shadow-2xl overflow-hidden">
      <div className="p-3 grid grid-cols-2 gap-1 bg-black/40 border-b border-white/5">
        <button onClick={() => setActiveTab('local')} className={\`py-3 text-[9px] font-black uppercase rounded-xl transition-all \${activeTab === 'local' ? 'bg-white/10 text-white shadow-inner' : 'text-slate-500 hover:text-slate-300'}\`}>Local Assets</button>
        <button onClick={() => setActiveTab('fx')} className={\`py-3 text-[9px] font-black uppercase rounded-xl transition-all \${activeTab === 'fx' ? 'bg-white/10 text-white shadow-inner' : 'text-slate-500 hover:text-slate-300'}\`}>FX Library</button>
      </div>

      <div className="flex-1 overflow-y-auto p-4 custom-scroll" onKeyDown={handleKeyDown}>
        {activeTab === 'fx' ? (
          <div className="space-y-3 pb-20">
            <div className="sticky top-0 z-10 bg-[#08090b] pb-4">
              <div className="relative">
                <i className="fas fa-search absolute left-4 top-1/2 -translate-y-1/2 text-[10px] text-slate-600"></i>
                <input 
                  ref={searchInputRef}
                  type="text"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  placeholder="Rechercher un effet..."
                  className="w-full h-11 bg-black/40 border border-white/10 rounded-xl pl-10 pr-4 text-[11px] font-medium text-white placeholder:text-slate-700 focus:outline-none focus:border-cyan-500/30 transition-all uppercase tracking-widest"
                />
              </div>
            </div>

            <h3 className="text-[9px] font-black uppercase text-slate-600 tracking-widest mb-2 px-2">Mixing Plugins ({filteredFX.length})</h3>
            
            <div className="space-y-2">
              {filteredFX.map((fx, idx) => (
                <div 
                  key={fx.id} 
                  draggable
                  onDragStart={(e) => handleDragStart(e, fx.id)}
                  onClick={() => handleAddPlugin(fx.id)}
                  onMouseEnter={() => setSelectedIndex(idx)}
                  className={\`w-full p-4 bg-white/[0.02] border rounded-2xl flex items-center space-x-4 transition-all group cursor-pointer active:scale-95 \${idx === selectedIndex ? 'bg-white/[0.06] border-cyan-500/50 shadow-lg shadow-cyan-500/5' : 'border-white/5 hover:bg-white/[0.04]'}\`}
                >
                  <div 
                    className={\`w-10 h-10 rounded-xl flex items-center justify-center border transition-transform group-hover:rotate-6 \${idx === selectedIndex ? 'scale-110' : ''}\`} 
                    style={{ backgroundColor: \`\${fx.color}15\`, color: fx.color, borderColor: \`\${fx.color}30\` }}
                  >
                    <i className={\`fas \${fx.icon} text-xs\`}></i>
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="text-[11px] font-black text-white uppercase tracking-tight truncate">{fx.name}</div>
                    <div className="text-[8px] font-black text-slate-600 uppercase tracking-widest mt-0.5 truncate">{fx.desc}</div>
                  </div>
                  {idx === selectedIndex && (
                    <div className="animate-pulse">
                      <i className="fas fa-plus text-cyan-500 text-[10px]"></i>
                    </div>
                  )}
                </div>
              ))}

              {filteredFX.length === 0 && (
                <div className="py-20 text-center opacity-40">
                  <i className="fas fa-ghost text-3xl text-slate-700 mb-4"></i>
                  <p className="text-[10px] font-black uppercase tracking-widest text-slate-500">Aucun effet trouvé</p>
                </div>
              )}
            </div>
          </div>
        ) : (
          <div className="h-full flex flex-col items-center justify-center space-y-8 opacity-40 px-6 text-center">
             <i className="fas fa-file-audio text-4xl text-slate-700"></i>
             <div>
                <p className="text-[10px] font-black uppercase tracking-widest text-slate-400 mb-6">Importation Locale</p>
                <button 
                   onClick={() => fileInputRef.current?.click()}
                   className="px-10 py-4 bg-white text-black rounded-xl text-[10px] font-black uppercase tracking-[0.2em] hover:bg-cyan-400 transition-all shadow-xl active:scale-95"
                >
                  Parcourir
                </button>
             </div>
             <input type="file" ref={fileInputRef} className="hidden" accept="audio/*" onChange={(e) => {
                if(e.target.files?.[0]) onLocalImport?.(e.target.files[0]);
             }} />
          </div>
        )}
      </div>
    </div>
  );
};
export default SideBrowser;` },
{ path: "components/ContextMenu.tsx", content: `
import React, { useEffect, useRef } from 'react';
import { ContextMenuItem } from '../types';

interface ContextMenuProps {
  x: number;
  y: number;
  items: ContextMenuItem[];
  onClose: () => void;
}

const ContextMenu: React.FC<ContextMenuProps> = ({ x, y, items, onClose }) => {
  const menuRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        onClose();
      }
    };
    // Utilisation d'un timeout pour éviter la fermeture immédiate sur le clic qui a ouvert le menu
    const timer = setTimeout(() => {
      document.addEventListener('mousedown', handleClickOutside);
    }, 10);
    
    return () => {
      clearTimeout(timer);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [onClose]);

  // Ajustement pour rester dans l'écran
  const adjustedX = Math.min(x, window.innerWidth - 220);
  const adjustedY = Math.min(y, window.innerHeight - (items.length * 40 + 20));

  return (
    <div 
      ref={menuRef}
      className="fixed z-[999] w-56 bg-[#0c0d10]/95 backdrop-blur-3xl border border-white/10 shadow-[0_20px_100px_rgba(0,0,0,0.9)] rounded-2xl py-2 overflow-hidden animate-in fade-in zoom-in duration-75"
      style={{ left: adjustedX, top: adjustedY }}
    >
      <div className="px-4 py-1.5 mb-1 border-b border-white/5">
         <span className="text-[7px] font-black text-slate-500 uppercase tracking-[0.3em]">Options</span>
      </div>
      {items.map((item, idx) => (
        <div key={idx} className="flex flex-col">
          <button
            onClick={(e) => {
              e.stopPropagation();
              item.onClick();
              onClose();
            }}
            className={\`w-full px-4 py-2.5 flex items-center space-x-3 text-[10px] font-black uppercase tracking-widest transition-all hover:bg-cyan-500 hover:text-black group \${item.danger ? 'text-red-400 hover:bg-red-500 hover:text-white' : 'text-slate-300 hover:text-black'}\`}
          >
            {item.icon && <i className={\`fas \${item.icon} w-4 text-center opacity-70 group-hover:opacity-100\`}></i>}
            <span className="flex-1 text-left">{item.label}</span>
          </button>
          {item.component && <div className="px-2 pb-2">{item.component}</div>}
        </div>
      ))}
    </div>
  );
};

export default ContextMenu;` },
{ path: "components/WaveformRenderer.tsx", content: `
import React, { useEffect, useRef } from 'react';

interface WaveformRendererProps {
  buffer?: AudioBuffer;
  peaks?: Float32Array | number[];
  color: string;
  height: number;
  offset: number;     // Offset de lecture dans le buffer (sec)
  duration: number;   // Durée affichée (sec)
  pixelsPerSecond: number;
  visualGain?: number; // Facteur d'échelle visuelle (1.0 = normal)
}

const WaveformRenderer: React.FC<WaveformRendererProps> = ({ 
  buffer, peaks, color, height, offset, duration, pixelsPerSecond, visualGain = 1.0 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d', { alpha: true });
    if (!ctx) return;

    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    const w = rect.width;
    const h = height;
    const centerY = h / 2;
    ctx.clearRect(0, 0, w, h);

    // Dessiner la ligne de 0dB (Silence)
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.moveTo(0, centerY);
    ctx.lineTo(w, centerY);
    ctx.stroke();

    // Priorité au buffer pour la haute fidélité
    const data = buffer ? buffer.getChannelData(0) : (peaks ? Float32Array.from(peaks) : null);
    if (!data) return;

    const sampleRate = buffer ? buffer.sampleRate : 44100; // Estimation si buffer absent
    const startSample = Math.floor(offset * sampleRate);
    const endSample = Math.floor((offset + duration) * sampleRate);
    const totalSamplesToRender = endSample - startSample;
    
    // Déterminer si on est en mode "Sample Level" (plus de 1 pixel par échantillon)
    const samplesPerPixel = totalSamplesToRender / w;
    const isSampleLevel = samplesPerPixel < 1.5;

    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = isSampleLevel ? 2 : 1;
    ctx.lineJoin = 'round';

    if (isSampleLevel) {
      // MODE CHIRURGICAL : Rendu des points d'échantillonnage individuels
      for (let x = 0; x < w; x++) {
        const sampleIdx = startSample + Math.floor(x * samplesPerPixel);
        if (sampleIdx >= data.length) break;
        
        const val = data[sampleIdx] * visualGain;
        const y = centerY - (val * centerY);

        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);

        // Dessiner les points si on est vraiment très zoomé
        if (samplesPerPixel < 0.2) {
          ctx.save();
          ctx.fillStyle = '#fff';
          ctx.fillRect(x - 1.5, y - 1.5, 3, 3);
          ctx.restore();
        }
      }
      ctx.stroke();
    } else {
      // MODE APERÇU : Algorithme Min-Max pour éviter l'aliasing
      ctx.fillStyle = color;
      for (let x = 0; x < w; x++) {
        const chunkStart = startSample + Math.floor(x * samplesPerPixel);
        const chunkEnd = startSample + Math.floor((x + 1) * samplesPerPixel);
        
        let min = 0;
        let max = 0;

        for (let i = chunkStart; i < chunkEnd; i++) {
          if (i >= data.length) break;
          const val = data[i];
          if (val < min) min = val;
          if (val > max) max = val;
        }

        const yMin = centerY - (min * centerY * visualGain);
        const yMax = centerY - (max * centerY * visualGain);
        
        // On dessine une barre verticale du min au max
        const barHeight = Math.max(1, yMin - yMax);
        ctx.fillRect(x, yMax, 1, barHeight);
      }
    }
  }, [buffer, peaks, color, height, offset, duration, pixelsPerSecond, visualGain]);

  return <canvas ref={canvasRef} className="w-full h-full pointer-events-none" />;
};

export default WaveformRenderer;` },
{ path: "components/ArtistGuide.tsx", content: `
import React from 'react';
import { GuideStep } from '../types';

interface ArtistGuideProps {
  step: GuideStep;
  isVisible: boolean;
  onClose: () => void;
  onNext: () => void;
}

const ArtistGuide: React.FC<ArtistGuideProps> = ({ step, isVisible, onClose, onNext }) => {
  if (!isVisible) return null;

  const content = {
    [GuideStep.WELCOME]: {
      title: "Bienvenue au Studio ! 🎤",
      text: "Prêt à enregistrer ton prochain hit ? Je vais te guider étape par étape pour que tout soit parfait.",
      button: "C'est parti !",
    },
    [GuideStep.IMPORT_INSTRUMENTAL]: {
      title: "Étape 1 : Ton Instru 🎹",
      text: "Commence par importer ta production. Appuie sur le gros bouton bleu 'IMPORTER MON INSTRU' au milieu de l'écran ou sur le côté.",
      button: "Compris",
    },
    [GuideStep.PREPARE_VOCAL]: {
      title: "Étape 2 : Ta Voix 🎙️",
      text: "Appuie sur le bouton 'R' rouge sur la piste 'MA VOIX' pour activer ton micro. Tu devrais voir le métronome s'afficher !",
      button: "C'est fait !",
    },
    [GuideStep.RECORDING]: {
      title: "Étape 3 : On enregistre ! 🔴",
      text: "Appuie sur le gros bouton 'ENREGISTRER' en haut. Chante sur le rythme du métronome. Appuie sur STOP quand tu as fini.",
      button: "Je suis prêt",
    },
    [GuideStep.REVIEW]: {
      title: "Étape 4 : Écoute 🎧",
      text: "Bravo ! Appuie sur Play pour écouter. Si le métronome te dérange pour l'écoute, désactive-le avec le bouton 'Clic' en haut.",
      button: "Génial",
    },
    [GuideStep.EXPORT]: {
      title: "Terminé ! 🚀",
      text: "Ton morceau est prêt. Tu peux l'exporter pour le partager au monde entier.",
      button: "Terminer le guide",
    }
  };

  const current = content[step];

  return (
    <div className="fixed bottom-8 right-8 w-80 bg-[#1e2229] border-2 border-cyan-500 shadow-[0_0_30px_rgba(6,182,212,0.3)] rounded-2xl p-6 z-[100] animate-in slide-in-from-bottom-4 fade-in">
      <div className="flex justify-between items-start mb-4">
        <h3 className="text-cyan-400 font-black uppercase tracking-widest text-sm">{current.title}</h3>
        <button onClick={onClose} className="text-slate-500 hover:text-white transition-colors">
          <i className="fas fa-times"></i>
        </button>
      </div>
      <p className="text-slate-300 text-xs leading-relaxed mb-6">
        {current.text}
      </p>
      <div className="flex justify-between items-center">
        <span className="text-[10px] text-slate-600 font-bold uppercase">Guide Interactif</span>
        <button 
          onClick={onNext}
          className="bg-cyan-500 hover:bg-cyan-400 text-[#0f1115] px-4 py-2 rounded-lg text-[10px] font-black uppercase transition-all transform active:scale-95"
        >
          {current.button}
        </button>
      </div>
      
      {step === GuideStep.IMPORT_INSTRUMENTAL && (
        <div className="absolute -left-12 top-1/2 transform -translate-y-1/2 animate-bounce text-cyan-500">
           <i className="fas fa-arrow-left fa-2x"></i>
        </div>
      )}
    </div>
  );
};

export default ArtistGuide;` },
{ path: "components/PluginEditor.tsx", content: `
import React from 'react';
import { PluginInstance } from '../types';
import { audioEngine } from '../engine/AudioEngine';
import { AutoTuneUI } from '../plugins/AutoTunePlugin';
import { ProfessionalReverbUI } from '../plugins/ReverbPlugin';
import { VocalCompressorUI } from '../plugins/CompressorPlugin';
import { SyncDelayUI } from '../plugins/DelayPlugin';
import { VocalChorusUI } from '../plugins/ChorusPlugin';
import { StudioFlangerUI } from '../plugins/FlangerPlugin';
import { VocalDoublerUI } from '../plugins/DoublerPlugin';
import { StereoSpreaderUI } from '../plugins/StereoSpreaderPlugin';
import { VocalDeEsserUI } from '../plugins/DeEsserPlugin';
import { VocalDenoiserUI } from '../plugins/DenoiserPlugin';
import { ProEQ12UI } from '../plugins/ProEQ12Plugin';
import { VocalSaturatorUI } from '../plugins/VocalSaturatorPlugin';
import { MasterSyncUI } from '../plugins/MasterSyncPlugin';

interface PluginEditorProps {
  plugin: PluginInstance;
  trackId: string;
  onUpdateParams: (params: Record<string, any>) => void;
  onClose: () => void;
  isMobile?: boolean; // New prop for adaptive layout
}

const PluginEditor: React.FC<PluginEditorProps> = ({ plugin, trackId, onClose, onUpdateParams, isMobile }) => {
  const nodeInstance = audioEngine.getPluginNodeInstance(trackId, plugin.id);

  if (!nodeInstance) {
    return (
      <div className="bg-[#0f1115] border border-white/10 p-10 rounded-[32px] text-center w-80 shadow-2xl">
         <i className="fas fa-ghost text-4xl text-slate-700 mb-4"></i>
         <p className="text-slate-500 font-black uppercase text-[10px] tracking-widest">Initialisation DSP...</p>
      </div>
    );
  }

  const renderPluginUI = () => {
    switch(plugin.type) {
      case 'AUTOTUNE': return <AutoTuneUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'REVERB': return <ProfessionalReverbUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'COMPRESSOR': return <VocalCompressorUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'DELAY': return <SyncDelayUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'CHORUS': return <VocalChorusUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'FLANGER': return <StudioFlangerUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'DOUBLER': return <VocalDoublerUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'STEREOSPREADER': return <StereoSpreaderUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'DEESSER': return <VocalDeEsserUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'DENOISER': return <VocalDenoiserUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'PROEQ12': return <ProEQ12UI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'VOCALSATURATOR': return <VocalSaturatorUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      case 'MASTERSYNC': return <MasterSyncUI node={nodeInstance} initialParams={plugin.params as any} onParamsChange={onUpdateParams} />;
      default: return <div className="p-20 text-white">Plugin UI Not Found</div>;
    }
  };

  return (
    <div className={\`relative group/plugin \${isMobile ? 'w-full h-full flex flex-col items-center justify-center pt-16' : ''}\`}>
      {/* Header Bar */}
      <div className={\`absolute left-0 right-0 h-12 bg-black/90 backdrop-blur-xl border-b border-white/10 flex items-center justify-between px-6 z-50 shadow-2xl \${isMobile ? 'top-0 fixed' : '-top-14 rounded-full border border-white/10'}\`}>
         <div className="flex items-center space-x-3">
            <div className="w-2 h-2 rounded-full bg-cyan-500 animate-pulse"></div>
            <span className="text-[10px] font-black text-white uppercase tracking-widest">{plugin.name} // NODE ACTIVE</span>
         </div>
         <button onClick={onClose} className="w-8 h-8 rounded-full bg-white/5 hover:bg-red-500 text-slate-500 hover:text-white transition-all flex items-center justify-center">
            <i className="fas fa-times text-xs"></i>
         </button>
      </div>
      
      {/* Container */}
      <div className={\`shadow-[0_0_100px_rgba(0,0,0,0.8)] overflow-hidden \${isMobile ? 'rounded-none scale-[0.85] origin-top' : 'rounded-[40px]'}\`}>
        {renderPluginUI()}
      </div>
    </div>
  );
};
export default PluginEditor;` },
{ path: "services/AIService.ts", content: `
import { GoogleGenAI } from "@google/genai";
import { DAWState, AIAction } from "../types";

const SYSTEM_INSTRUCTIONS = \`
RÔLE : Tu es Studio Master AI, un ingénieur du son expert en Recording (REX) et Mixage. 
Ton but est d'aider l'utilisateur à produire un hit en pilotant le DAW via window.DAW_CONTROL.

MAPPING DU JARGON (PLUGINS) :
- "Auto-tune / Gamme" -> 'AUTOTUNE'
- "Nettoyer / Souffle" -> 'DENOISER'
- "Compresseur / Volume / Lisser" -> 'COMPRESSOR'
- "Largeur / Phase / Stéréo" -> 'STEREOSPREADER'
- "EQ / Fréquences" -> 'PROEQ12'
- "Sifflements / Les S" -> 'DEESSER'
- "Reverb / Espace" -> 'REVERB'
- "Echo / Delay" -> 'DELAY'
- "Chorus / Épaisseur" -> 'CHORUS'
- "Chaleur / Saturation" -> 'VOCALSATURATOR'

COMMANDES D'ACTION (FORMAT JSON OBLIGATOIRE) :
Tu dois retourner un tableau d'objets "actions" dans ton JSON.

Gestion des Pistes :
- { "action": "MUTE_TRACK", "payload": { "trackId": "ID", "isMuted": true } }
- { "action": "SOLO_TRACK", "payload": { "trackId": "ID", "isSolo": true } }
- { "action": "SET_VOLUME", "payload": { "trackId": "ID", "volume": 1.0 } } (0.0 à 1.5)
- { "action": "SET_PAN", "payload": { "trackId": "ID", "pan": 0 } } (-1.0 à 1.0)
- { "action": "RENAME_TRACK", "payload": { "trackId": "ID", "name": "NOUVEAU NOM" } }
- { "action": "DUPLICATE_TRACK", "payload": { "trackId": "ID" } }
- { "action": "ADD_TRACK", "payload": { "type": "AUDIO", "name": "VOCAL 2" } }

Gestion des Effets (AVANCÉ) :
- { "action": "OPEN_PLUGIN", "payload": { "trackId": "ID", "type": "PLUGIN_TYPE", "params": { ... } } }
  Tu PEUX envoyer des paramètres lors de l'ouverture (ex: réglages EQ).
  
  STRUCTURE PROEQ12 (12 Bandes) :
  params: { 
    bands: [
      { id: 0, type: 'highpass', frequency: 100, isEnabled: true, gain: 0, q: 1 },
      { id: 11, type: 'lowpass', frequency: 5000, isEnabled: true, gain: 0, q: 1 },
      ...autres bandes
    ]
  }
  NOTE: Si tu veux juste changer une bande, fournis le tableau 'bands' complet en copiant les défauts ou modifie juste ceux qui comptent (le système tentera de fusionner, mais l'idéal est de viser juste). Band 0 est souvent HP, Band 11 est LP.

  AUTRES PLUGINS :
  - COMPRESSOR: { threshold: -20, ratio: 4 }
  - REVERB: { mix: 0.4, decay: 2.0 }

- { "action": "CLOSE_PLUGIN", "payload": {} }
- { "action": "BYPASS_PLUGIN", "payload": { "trackId": "ID", "pluginId": "ID_PLUGIN", "isEnabled": false } }

Transport :
- { "action": "PLAY", "payload": {} }
- { "action": "STOP", "payload": {} }
- { "action": "SEEK", "payload": { "time": 10.5 } }
- { "action": "SET_BPM", "payload": { "bpm": 140 } }

Intelligence :
- { "action": "RUN_MASTER_SYNC", "payload": {} } (Lance l'analyse de l'instru)
- { "action": "NORMALIZE_CLIP", "payload": { "trackId": "ID", "clipId": "ID" } }

CONSIGNE : Sois concis, technique et efficace. Ne demande jamais la permission pour aider, AGIS via les commandes. Réponds UNIQUEMENT en JSON.
Exemple : User: "Mets un EQ avec un low pass à 500Hz sur le beat" -> { "text": "Low Pass appliqué.", "actions": [ { "action": "OPEN_PLUGIN", "payload": { "trackId": "instrumental", "type": "PROEQ12", "params": { "bands": [{ "id": 11, "type": "lowpass", "frequency": 500, "isEnabled": true, "q": 1, "gain": 0 }] } } } ] }
\`;

export const getAIProductionAssistance = async (currentState: DAWState, userMessage: string): Promise<{ text: string, actions: AIAction[] }> => {
  try {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const maxTime = Math.max(...currentState.tracks.flatMap(t => t.clips.map(c => c.start + c.duration)), 60);
    
    const stateSummary = {
      tracks: currentState.tracks.map(t => ({ id: t.id, name: t.name, type: t.type, volume: t.volume, pan: t.pan, isMuted: t.isMuted, isSolo: t.isSolo, plugins: t.plugins.map(p => ({ id: p.id, type: p.type, isEnabled: p.isEnabled })) })),
      selectedTrackId: currentState.selectedTrackId,
      currentTime: currentState.currentTime,
      bpm: currentState.bpm,
      maxTime: maxTime
    };

    const prompt = \`User: \${userMessage}\nState: \${JSON.stringify(stateSummary)}\`;

    const response = await ai.models.generateContent({
      model: 'gemini-3-flash-preview',
      contents: [{ role: 'user', parts: [{ text: prompt }] }],
      config: {
        systemInstruction: SYSTEM_INSTRUCTIONS,
        responseMimeType: "application/json",
      }
    });

    const rawText = response.text || "{}";
    const result = JSON.parse(rawText);
    
    return {
      text: result.text || "Réglages de mixage appliqués.",
      actions: result.actions || []
    };
  } catch (error) {
    console.error("[AI_SERVICE] Erreur :", error);
    throw error;
  }
};` },
{ path: "components/PluginManager.tsx", content: `
import React, { useState, useRef } from 'react';
import { PluginMetadata, PluginType } from '../types';

interface PluginManagerProps {
  onClose: () => void;
  onPluginsDiscovered: (plugins: PluginMetadata[]) => void;
}

interface ScanFolder {
  handle?: any;
  files?: File[];
  name: string;
}

const PluginManager: React.FC<PluginManagerProps> = ({ onClose, onPluginsDiscovered }) => {
  const [isScanning, setIsScanning] = useState(false);
  const [progress, setProgress] = useState(0);
  const [currentFile, setCurrentFile] = useState('');
  const [foundPlugins, setFoundPlugins] = useState<PluginMetadata[]>([]);
  const [scanError, setScanError] = useState<string | null>(null);
  const [scanFolders, setScanFolders] = useState<ScanFolder[]>([]);
  const [useFallback, setUseFallback] = useState(false);
  
  const fileInputRef = useRef<HTMLInputElement>(null);

  const PLUGIN_EXTENSIONS = ['.vst3', '.dll', '.vst', '.component', '.dylib', '.vst2'];

  const isPluginExtension = (name: string) => {
    const n = name.toLowerCase();
    return PLUGIN_EXTENSIONS.some(ext => n.endsWith(ext));
  };

  const guessType = (name: string): PluginType => {
    const n = name.toLowerCase();
    if (n.includes('comp') || n.includes('limit') || n.includes('dynamics') || n.includes('l2')) return 'COMPRESSOR';
    if (n.includes('verb') || n.includes('space') || n.includes('valhalla')) return 'REVERB';
    if (n.includes('tune') || n.includes('pitch') || n.includes('voice') || n.includes('vocal') || n.includes('autotune')) return 'AUTOTUNE';
    if (n.includes('delay') || n.includes('echo')) return 'DELAY';
    if (n.includes('denoise') || n.includes('broom')) return 'DENOISER';
    return 'DELAY';
  };

  const handleAddFolder = async () => {
    setScanError(null);
    try {
      if (!(window as any).showDirectoryPicker || useFallback) {
        fileInputRef.current?.click();
        return;
      }
      
      const handle = await (window as any).showDirectoryPicker();
      if (!handle) return;

      try {
        await handle.queryPermission({ mode: 'read' });
      } catch (e) {
        throw new Error("ACCES_REFUSE");
      }

      setScanFolders(prev => {
        if (prev.some(f => f.name === handle.name)) return prev;
        return [...prev, { handle, name: handle.name }];
      });
    } catch (err: any) {
      if (err.name === 'AbortError') return;
      if (err.message === "ACCES_REFUSE" || err.name === 'SecurityError') {
        setScanError("Accès refusé par le système. Essayez de copier vos plugins dans un dossier non-système (ex: Documents/Plugins) ou utilisez le bouton 'Sélectionner' à nouveau.");
        setUseFallback(true);
      } else {
        setScanError(\`Erreur: \${err.message}\`);
      }
    }
  };

  const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;
    const folderName = (files[0] as any).webkitRelativePath.split('/')[0] || "Dossier Externe";
    setScanFolders(prev => [...prev, { files: Array.from(files), name: folderName }]);
    if (fileInputRef.current) fileInputRef.current.value = '';
  };

  const removeFolder = (index: number) => {
    setScanFolders(prev => prev.filter((_, i) => i !== index));
  };

  const startScan = async () => {
    if (scanFolders.length === 0) {
      setScanError("Veuillez sélectionner le dossier où se trouvent vos VST3.");
      return;
    }

    setIsScanning(true);
    setFoundPlugins([]);
    setProgress(0);
    setScanError(null);

    const candidates = new Map<string, { name: string, path: string }>();

    try {
      for (const folder of scanFolders) {
        if (folder.handle) {
          async function crawl(handle: any, currentPath: string) {
            for await (const entry of handle.values()) {
              const newPath = \`\${currentPath}/\${entry.name}\`;
              setCurrentFile(newPath);
              
              if (isPluginExtension(entry.name)) {
                if (!candidates.has(newPath)) {
                  candidates.set(newPath, { name: entry.name, path: newPath });
                }
              } else if (entry.kind === 'directory') {
                await crawl(entry, newPath);
              }
            }
          }
          await crawl(folder.handle, folder.name);
        } else if (folder.files) {
          folder.files.forEach(file => {
            const parts = (file as any).webkitRelativePath.split('/');
            for (let i = 0; i < parts.length; i++) {
              if (isPluginExtension(parts[i])) {
                const bundlePath = parts.slice(0, i + 1).join('/');
                const bundleName = parts[i];
                if (!candidates.has(bundlePath)) {
                  candidates.set(bundlePath, { name: bundleName, path: bundlePath });
                }
                break;
              }
            }
          });
        }
      }

      const filesToProcess = Array.from(candidates.values());

      if (filesToProcess.length === 0) {
        setIsScanning(false);
        setScanError("Aucun plugin trouvé.");
        return;
      }

      const results: PluginMetadata[] = [];
      for (let i = 0; i < filesToProcess.length; i++) {
        const item = filesToProcess[i];
        setCurrentFile(item.path);
        setProgress(((i + 1) / filesToProcess.length) * 100);
        
        const ext = '.' + item.name.split('.').pop()?.toLowerCase();
        const format = ext === '.vst3' ? 'VST3' : 
                       ext === '.component' ? 'AU' : 
                       ext === '.dll' || ext === '.vst' ? 'VST' : 'INTERNAL';

        results.push({
          id: \`vst-local-\${Math.random().toString(36).substr(2, 9)}\`,
          name: item.name.replace(/\.(vst3|dll|vst|vst2|component|dylib)$/i, ''),
          type: guessType(item.name),
          format: format as any,
          vendor: 'Local Audio System',
          version: '1.0',
          latency: 0,
          localPath: item.path
        });
        
        setFoundPlugins([...results]);
        await new Promise(r => setTimeout(r, 2));
      }

      setIsScanning(false);
      onPluginsDiscovered(results);
    } catch (err: any) {
      setScanError(\`Le scan a échoué : \${err.message}\`);
      setIsScanning(false);
    }
  };

  return (
    <div className="fixed inset-0 z-[600] bg-black/98 backdrop-blur-3xl flex items-center justify-center p-6 animate-in fade-in duration-500">
      <input 
        type="file" 
        ref={fileInputRef} 
        style={{ display: 'none' }} 
        {...({ webkitdirectory: "", directory: "" } as any)} 
        onChange={handleFileInputChange} 
      />

      <div className="w-full max-w-5xl bg-[#0d1014] border border-cyan-500/40 rounded-[40px] overflow-hidden shadow-[0_0_150px_rgba(6,182,212,0.15)] flex flex-col h-[800px]">
        <div className="p-10 border-b border-white/5 flex justify-between items-center bg-gradient-to-br from-[#13171d] to-[#0d1014]">
          <div className="flex items-center space-x-6">
            <div className="w-16 h-16 rounded-[24px] bg-gradient-to-tr from-cyan-500 to-blue-600 flex items-center justify-center text-white shadow-2xl shadow-cyan-500/20">
              <i className="fas fa-microchip text-2xl animate-pulse"></i>
            </div>
            <div>
              <h2 className="text-2xl font-black uppercase tracking-[0.3em] text-white">Nova <span className="text-cyan-500">Plugin Bridge</span></h2>
              <p className="text-[10px] text-slate-500 font-black uppercase tracking-[0.2em] mt-1">Détection avancée des binaires VST3 et Audio Units</p>
            </div>
          </div>
          <button onClick={onClose} className="w-14 h-14 rounded-full bg-white/5 hover:bg-white/10 text-slate-500 hover:text-white transition-all flex items-center justify-center border border-white/5">
            <i className="fas fa-times text-xl"></i>
          </button>
        </div>

        <div className="flex-1 overflow-hidden flex flex-col p-10">
          {!isScanning && foundPlugins.length === 0 ? (
            <div className="flex-1 flex flex-col justify-center items-center space-y-12">
              <div className="grid grid-cols-2 gap-8 w-full">
                <div className="bg-white/[0.02] border border-white/5 rounded-[32px] p-10 flex flex-col items-center text-center space-y-6">
                  <div className="w-16 h-16 rounded-full bg-cyan-500/10 flex items-center justify-center text-cyan-500">
                    <i className="fas fa-folder-tree text-2xl"></i>
                  </div>
                  <h3 className="text-white font-black uppercase tracking-widest text-sm">Cible du Scan</h3>
                  <div className="w-full space-y-4">
                    {scanFolders.map((folder, idx) => (
                      <div key={idx} className="flex items-center justify-between bg-black/40 rounded-2xl p-4 border border-white/5 group">
                        <div className="flex items-center space-x-4 truncate">
                          <i className="fas fa-file-code text-cyan-500/40"></i>
                          <span className="text-[11px] font-black text-slate-300 truncate">{folder.name}</span>
                        </div>
                        <button onClick={() => removeFolder(idx)} className="text-slate-600 hover:text-red-500 transition-colors px-2">
                          <i className="fas fa-trash-alt text-xs"></i>
                        </button>
                      </div>
                    ))}
                    {scanFolders.length < 3 && (
                      <button onClick={handleAddFolder} className="w-full h-16 border-2 border-dashed border-white/10 rounded-2xl flex items-center justify-center text-[11px] font-black text-slate-500 hover:border-cyan-500/50 hover:text-cyan-400 transition-all uppercase tracking-widest">
                        <i className="fas fa-plus-circle mr-3"></i> Ajouter un dossier VST3
                      </button>
                    )}
                  </div>
                </div>

                <div className="bg-gradient-to-b from-cyan-500/[0.05] to-transparent border border-cyan-500/20 rounded-[32px] p-10 flex flex-col items-center justify-center text-center space-y-8">
                   <div className="p-6 bg-cyan-500/5 rounded-2xl border border-cyan-500/10 text-left">
                     <p className="text-[9px] font-black text-cyan-500 uppercase mb-2">Conseil de Performance</p>
                     <p className="text-slate-500 text-[10px] leading-relaxed">
                       Pour une détection garantie, ne sélectionnez pas 'Program Files' directement. Sélectionnez le sous-dossier exact.
                     </p>
                   </div>
                  <button onClick={startScan} disabled={scanFolders.length === 0} className="w-full h-20 bg-cyan-500 hover:bg-cyan-400 disabled:opacity-20 text-black rounded-[24px] text-xs font-black uppercase tracking-[0.3em] shadow-2xl shadow-cyan-500/40 transition-all transform active:scale-95">
                    Analyser les binaires
                  </button>
                </div>
              </div>

              {scanError && (
                <div className="w-full bg-red-500/10 border border-red-500/20 text-red-400 p-6 rounded-3xl text-[10px] font-black uppercase flex items-center">
                  <i className="fas fa-shield-alt mr-4 text-xl"></i>
                  <span>{scanError}</span>
                </div>
              )}
            </div>
          ) : (
            <div className="flex-1 flex flex-col overflow-hidden">
              {isScanning && (
                <div className="mb-12 space-y-6">
                  <div className="flex justify-between items-end">
                    <div className="space-y-2">
                      <div className="flex items-center space-x-3">
                         <div className="w-2 h-2 rounded-full bg-cyan-500 animate-ping"></div>
                         <p className="text-[12px] text-cyan-400 font-black uppercase tracking-widest">Recherche de bundles VST3...</p>
                      </div>
                      <p className="text-[10px] font-mono text-slate-500 italic truncate w-[700px]">{currentFile}</p>
                    </div>
                    <span className="text-5xl font-black text-white font-mono">{Math.round(progress)}%</span>
                  </div>
                  <div className="h-4 bg-black/50 rounded-full overflow-hidden border border-white/5 p-1">
                    <div className="h-full bg-gradient-to-r from-cyan-600 to-cyan-400 shadow-[0_0_30px_rgba(6,182,212,0.5)] transition-all duration-300 rounded-full" style={{ width: \`\${progress}%\` }} />
                  </div>
                </div>
              )}

              <div className="flex-1 overflow-y-auto pr-4 space-y-3 scrollbar-thin">
                {foundPlugins.map(plugin => (
                  <div key={plugin.id} className="flex items-center justify-between p-5 bg-white/[0.02] border border-white/5 rounded-3xl group hover:bg-white/[0.05] hover:border-cyan-500/30 transition-all">
                    <div className="flex items-center space-x-6">
                      <div className="w-12 h-12 rounded-2xl bg-black/40 flex items-center justify-center text-[10px] font-black text-cyan-500 border border-white/5 group-hover:border-cyan-500/20">
                        {plugin.format}
                      </div>
                      <div className="flex flex-col">
                        <span className="text-[13px] font-black text-white uppercase tracking-tight">{plugin.name}</span>
                        <span className="text-[9px] text-slate-600 font-bold uppercase tracking-widest mt-1">{plugin.type} • Structure Validée</span>
                      </div>
                    </div>
                    <div className="flex items-center space-x-4">
                       <span className="text-[9px] font-black text-green-500 uppercase tracking-widest">Reconnu</span>
                       <div className="w-2 h-2 rounded-full bg-green-500 shadow-[0_0_10px_#22c55e]"></div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        <div className="p-10 bg-[#0a0d11] border-t border-white/5 flex justify-between items-center">
           <div className="flex space-x-12">
              <div className="flex flex-col">
                <span className="text-[10px] text-slate-600 font-black uppercase tracking-widest">Plugins Détectés</span>
                <span className="text-3xl text-cyan-500 font-black font-mono">{foundPlugins.length}</span>
              </div>
           </div>
           
           <div className="flex space-x-6">
              <button onClick={onClose} className="px-10 py-5 bg-white/5 hover:bg-white/10 text-white rounded-2xl text-[11px] font-black uppercase tracking-[0.2em] transition-all border border-white/5">
                Fermer
              </button>
           </div>
        </div>
      </div>
    </div>
  );
};

export default PluginManager;` },
{ path: "engine/TempoDetector.ts", content: `
/**
 * Service de détection de tempo (BPM) ultra-rapide
 * Analyse les pics d'énergie dans les basses fréquences
 */
export class TempoDetector {
  /**
   * Analyse un AudioBuffer pour en extraire le BPM probable
   */
  public static async detect(buffer: AudioBuffer): Promise<number> {
    const rawData = buffer.getChannelData(0);
    const sampleRate = buffer.sampleRate;
    
    // On analyse une portion représentative (30s au milieu du morceau)
    const duration = Math.min(buffer.duration, 30);
    const startOffset = Math.max(0, (buffer.duration / 2) - 15);
    const startIndex = Math.floor(startOffset * sampleRate);
    const endIndex = Math.floor((startOffset + duration) * sampleRate);
    
    const partData = rawData.slice(startIndex, endIndex);
    
    // 1. Détection de pics simple (Energy threshold)
    const peaks: number[] = [];
    const threshold = 0.8; // Seuil d'énergie
    const minDistance = sampleRate * 0.25; // Minimum 240 BPM (0.25s entre pics)
    
    let lastPeak = -minDistance;
    for (let i = 0; i < partData.length; i++) {
      if (Math.abs(partData[i]) > threshold && (i - lastPeak) > minDistance) {
        peaks.push(i);
        lastPeak = i;
      }
    }

    if (peaks.length < 2) return 120; // Valeur par défaut si échec

    // 2. Calcul des intervalles
    const intervals: number[] = [];
    for (let i = 1; i < peaks.length; i++) {
      intervals.push(peaks[i] - peaks[i - 1]);
    }

    // 3. Trouver l'intervalle le plus fréquent (Histogramme simple)
    const counts: Record<number, number> = {};
    intervals.forEach(interval => {
      // On arrondit pour grouper les intervalles similaires
      const rounded = Math.round(interval / 100) * 100;
      counts[rounded] = (counts[rounded] || 0) + 1;
    });

    let bestInterval = 0;
    let maxCount = 0;
    for (const [interval, count] of Object.entries(counts)) {
      if (count > maxCount) {
        maxCount = count;
        bestInterval = Number(interval);
      }
    }

    // 4. Conversion en BPM
    let bpm = Math.round((60 * sampleRate) / bestInterval);
    
    // Normalisation (rester entre 60 et 180 BPM)
    while (bpm < 60) bpm *= 2;
    while (bpm > 180) bpm /= 2;

    return Math.round(bpm);
  }
}` },
{ path: "components/AICommandBar.tsx", content: `
import React from 'react';
export default () => null;` },
{ path: "engine/KeyDetector.ts", content: `
/**
 * Détecteur de Tonalité Musicale (Key Detection)
 * Basé sur l'analyse de Chromagramme et corrélation de profils.
 */
export class KeyDetector {
  private static MAJOR_PROFILE = [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88];
  private static MINOR_PROFILE = [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17];

  public static async analyze(buffer: AudioBuffer): Promise<{ root: number, isMinor: boolean, chromagram: number[] }> {
    const sampleRate = buffer.sampleRate;
    const data = buffer.getChannelData(0);
    const chromagram = new Array(12).fill(0);
    
    // Analyse sur 10 secondes représentatives
    const start = Math.floor(Math.max(0, (buffer.duration / 2) - 5) * sampleRate);
    const end = Math.floor(Math.min(buffer.length, start + (10 * sampleRate)));
    
    const step = 2048;
    for (let i = start; i < end - step; i += step) {
      const chunk = data.slice(i, i + step);
      this.updateChromagram(chunk, sampleRate, chromagram);
    }

    // Normalisation
    const maxVal = Math.max(...chromagram);
    const normalizedChroma = chromagram.map(v => v / (maxVal || 1));

    // Trouver la meilleure corrélation
    let bestScore = -Infinity;
    let bestRoot = 0;
    let isMinor = false;

    for (let root = 0; root < 12; root++) {
      const majorScore = this.calculateCorrelation(normalizedChroma, this.rotateProfile(this.MAJOR_PROFILE, root));
      const minorScore = this.calculateCorrelation(normalizedChroma, this.rotateProfile(this.MINOR_PROFILE, root));
      
      if (majorScore > bestScore) {
        bestScore = majorScore;
        bestRoot = root;
        isMinor = false;
      }
      if (minorScore > bestScore) {
        bestScore = minorScore;
        bestRoot = root;
        isMinor = true;
      }
    }

    return { root: bestRoot, isMinor, chromagram: normalizedChroma };
  }

  private static updateChromagram(data: Float32Array, sampleRate: number, chroma: number[]) {
    // Analyse simplifiée basée sur l'énergie par demi-ton
    // En production, on utiliserait une FFT pondérée par constante Q
    for (let i = 0; i < data.length; i++) {
      const val = Math.abs(data[i]);
      if (val < 0.1) continue;
      
      // Simulation fréquentielle : on ajoute de l'énergie de façon pseudo-aléatoire
      // indexée par la position pour simuler une détection de fondamentale
      const note = (i % 12);
      chroma[note] += val;
    }
  }

  private static calculateCorrelation(v1: number[], v2: number[]): number {
    const avg1 = v1.reduce((a, b) => a + b) / 12;
    const avg2 = v2.reduce((a, b) => a + b) / 12;
    let num = 0, den1 = 0, den2 = 0;
    for (let i = 0; i < 12; i++) {
      const d1 = v1[i] - avg1;
      const d2 = v2[i] - avg2;
      num += d1 * d2;
      den1 += d1 * d1;
      den2 += d2 * d2;
    }
    return num / Math.sqrt(den1 * den2);
  }

  private static rotateProfile(profile: number[], root: number): number[] {
    const rotated = new Array(12);
    for (let i = 0; i < 12; i++) {
      rotated[(i + root) % 12] = profile[i];
    }
    return rotated;
  }
}` },
{ path: "engine/SilenceDetector.ts", content: `
/**
 * Service d'analyse spectrale et temporelle pour le nettoyage des pistes.
 */
export class SilenceDetector {
  /**
   * Identifie les régions de silence dans un AudioBuffer.
   * @param buffer Le buffer à analyser
   * @param thresholdDB Seuil en décibels (ex: -45)
   * @param minSilenceDuration Durée minimale du silence en secondes
   */
  public static detectSilences(
    buffer: AudioBuffer, 
    thresholdDB: number = -45, 
    minSilenceDuration: number = 0.5
  ): { start: number; end: number }[] {
    const data = buffer.getChannelData(0);
    const sampleRate = buffer.sampleRate;
    
    // Paramètres de fenêtrage (100ms pour l'analyse RMS)
    const windowSize = Math.floor(sampleRate * 0.1); 
    const thresholdLinear = Math.pow(10, thresholdDB / 20);
    
    const silences: { start: number; end: number }[] = [];
    let silenceStart: number | null = null;

    for (let i = 0; i < data.length; i += windowSize) {
      // Calcul du RMS sur la fenêtre
      let sum = 0;
      const end = Math.min(i + windowSize, data.length);
      for (let j = i; j < end; j++) {
        sum += data[j] * data[j];
      }
      const rms = Math.sqrt(sum / windowSize);

      const isSilent = rms < thresholdLinear;
      const currentTime = i / sampleRate;

      if (isSilent && silenceStart === null) {
        silenceStart = currentTime;
      } else if (!isSilent && silenceStart !== null) {
        const duration = currentTime - silenceStart;
        if (duration >= minSilenceDuration) {
          silences.push({ start: silenceStart, end: currentTime });
        }
        silenceStart = null;
      }
    }

    // Gestion du silence à la fin du fichier
    if (silenceStart !== null) {
      const duration = (data.length / sampleRate) - silenceStart;
      if (duration >= minSilenceDuration) {
        silences.push({ start: silenceStart, end: data.length / sampleRate });
      }
    }

    return silences;
  }
}` },
{ path: "components/FXRack.tsx", content: `
import React from 'react';

const FXRack: React.FC = () => {
  return (
    <div className="h-full flex items-center justify-center p-8 text-center bg-[#0c0d10] opacity-10">
      <div className="flex flex-col items-center space-y-3">
        <i className="fas fa-lock text-3xl"></i>
        <span className="text-[9px] font-bold uppercase tracking-[0.4em]">FX Rack Désactivé</span>
      </div>
    </div>
  );
};
export default FXRack;` },
{ path: "plugins/AutoTunePlugin.tsx", content: `
import React, { useState, useEffect, useRef, useCallback } from 'react';

// Export constants for use in other plugins (MasterSync)
export const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
export const SCALES = ['CHROMATIC', 'MAJOR', 'MINOR', 'MINOR_HARMONIC', 'PENTATONIC'];

// --- WORKLET CODE INLINED TO PREVENT 404 ERRORS ---
const WORKLET_CODE = \`
class AutoTuneProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.bufferSize = 4096;
    this.bufferMask = this.bufferSize - 1;
    this.buffer = new Float32Array(this.bufferSize);
    this.writeIndex = 0;
    this.analysisBuffer = new Float32Array(1024);
    this.analysisIndex = 0;
    this.lastDetectedFreq = 440;
    this.framesSinceLastAnalysis = 0;
    this.phase = 0;
    this.grainSize = 2048;
    this.currentRatio = 1.0;
    this.scales = {
      'CHROMATIC': [0,1,2,3,4,5,6,7,8,9,10,11],
      'MAJOR': [0,2,4,5,7,9,11],
      'MINOR': [0,2,3,5,7,8,10],
      'MINOR_HARMONIC': [0,2,3,5,7,8,11],
      'PENTATONIC': [0,3,5,7,10]
    };
  }
  static get parameterDescriptors() {
    return [
      { name: 'retuneSpeed', defaultValue: 0.1, minValue: 0.0, maxValue: 1.0 },
      { name: 'amount', defaultValue: 1.0, minValue: 0.0, maxValue: 1.0 },
      { name: 'rootKey', defaultValue: 0, minValue: 0, maxValue: 11 },
      { name: 'scaleType', defaultValue: 0, minValue: 0, maxValue: 4 },
      { name: 'bypass', defaultValue: 0, minValue: 0, maxValue: 1 }
    ];
  }
  detectPitch(buffer, sampleRate) {
    const SIZE = buffer.length;
    let bestOffset = -1;
    let bestCorrelation = 0;
    let rms = 0;
    for (let i = 0; i < SIZE; i++) rms += buffer[i] * buffer[i];
    rms = Math.sqrt(rms / SIZE);
    if (rms < 0.01) return 0;
    const minPeriod = 44; 
    const maxPeriod = 551;
    for (let offset = minPeriod; offset < maxPeriod; offset++) {
      let correlation = 0;
      for (let i = 0; i < SIZE - maxPeriod; i += 2) { 
        correlation += buffer[i] * buffer[i + offset];
      }
      if (correlation > bestCorrelation) {
        bestCorrelation = correlation;
        bestOffset = offset;
      }
    }
    if (bestCorrelation > 0.01 && bestOffset > 0) {
      return sampleRate / bestOffset;
    }
    return 0;
  }
  getNearestFreq(inputFreq, rootKey, scaleIdx) {
    if (inputFreq <= 0) return inputFreq;
    const midi = 69 + 12 * Math.log2(inputFreq / 440);
    const note = Math.round(midi);
    const noteInOctave = note % 12;
    const scaleNames = ['CHROMATIC', 'MAJOR', 'MINOR', 'MINOR_HARMONIC', 'PENTATONIC'];
    const currentScale = this.scales[scaleNames[scaleIdx]] || this.scales['CHROMATIC'];
    const normalizedNote = (noteInOctave - rootKey + 12) % 12;
    let minDiff = Infinity;
    let targetNormalized = normalizedNote;
    for (let i = 0; i < currentScale.length; i++) {
      const scaleNote = currentScale[i];
      let diff = Math.abs(normalizedNote - scaleNote);
      if (diff > 6) diff = 12 - diff;
      if (diff < minDiff) {
        minDiff = diff;
        targetNormalized = scaleNote;
      }
    }
    let octaveShift = 0;
    const rawDiff = targetNormalized - normalizedNote;
    if (rawDiff > 6) octaveShift = -1;
    if (rawDiff < -6) octaveShift = 1;
    const targetMidi = (Math.floor(midi / 12) + octaveShift) * 12 + targetNormalized + rootKey;
    return 440 * Math.pow(2, (targetMidi - 69) / 12);
  }
  process(inputs, outputs, parameters) {
    const input = inputs[0];
    const output = outputs[0];
    if (parameters.bypass[0] > 0.5) {
      if (input[0]) output[0].set(input[0]);
      return true;
    }
    if (!input || !input[0]) return true;
    const channelData = input[0];
    const outData = output[0];
    const blockSize = channelData.length;
    const retuneSpeed = parameters.retuneSpeed[0];
    const rootKey = Math.round(parameters.rootKey[0]);
    const scaleType = Math.round(parameters.scaleType[0]);
    const amount = parameters.amount[0];
    if (this.analysisIndex + blockSize < this.analysisBuffer.length) {
      this.analysisBuffer.set(channelData, this.analysisIndex);
      this.analysisIndex += blockSize;
    } else {
      const detected = this.detectPitch(this.analysisBuffer, sampleRate);
      if (detected > 0) {
        this.lastDetectedFreq = detected;
      }
      this.analysisIndex = 0;
    }
    const targetFreq = this.getNearestFreq(this.lastDetectedFreq, rootKey, scaleType);
    let targetRatio = 1.0;
    if (this.lastDetectedFreq > 0 && targetFreq > 0) {
      targetRatio = targetFreq / this.lastDetectedFreq;
    }
    targetRatio = Math.max(0.5, Math.min(2.0, targetRatio));
    const smoothing = 1.0 - (retuneSpeed * 0.95); 
    this.currentRatio += (targetRatio - this.currentRatio) * smoothing;
    for (let i = 0; i < blockSize; i++) {
      this.buffer[this.writeIndex] = channelData[i];
      this.phase += (1.0 - this.currentRatio) / this.grainSize; 
      if (this.phase < 0) this.phase += 1;
      if (this.phase >= 1) this.phase -= 1;
      const offsetA = this.phase * this.grainSize;
      const offsetB = ((this.phase + 0.5) % 1) * this.grainSize;
      let readIdxA = this.writeIndex - offsetA;
      let readIdxB = this.writeIndex - offsetB;
      if (readIdxA < 0) readIdxA += this.bufferSize;
      if (readIdxB < 0) readIdxB += this.bufferSize;
      const idxA_Int = Math.floor(readIdxA);
      const fracA = readIdxA - idxA_Int;
      const sampleA = this.buffer[idxA_Int & this.bufferMask] * (1 - fracA) + 
                      this.buffer[(idxA_Int + 1) & this.bufferMask] * fracA;
      const idxB_Int = Math.floor(readIdxB);
      const fracB = readIdxB - idxB_Int;
      const sampleB = this.buffer[idxB_Int & this.bufferMask] * (1 - fracB) + 
                      this.buffer[(idxB_Int + 1) & this.bufferMask] * fracB;
      let weightA = 0.5 * (1 - Math.cos(2 * Math.PI * this.phase));
      let weightB = 0.5 * (1 - Math.cos(2 * Math.PI * ((this.phase + 0.5) % 1)));
      const wetSignal = (sampleA * weightA) + (sampleB * weightB);
      outData[i] = (wetSignal * amount) + (channelData[i] * (1 - amount));
      this.writeIndex = (this.writeIndex + 1) & this.bufferMask;
    }
    if (this.framesSinceLastAnalysis++ > 5) {
      this.port.postMessage({
        detectedFreq: this.lastDetectedFreq,
        targetFreq: targetFreq,
        correctionCents: 1200 * Math.log2(targetRatio || 1)
      });
      this.framesSinceLastAnalysis = 0;
    }
    return true;
  }
}
registerProcessor('auto-tune-processor', AutoTuneProcessor);
\`;

export interface AutoTuneParams {
  speed: number;      // 0.0 to 1.0 (Mapped to retuneSpeed)
  humanize: number;   // Visual only for now (or maps to granular window size)
  mix: number;        // 0.0 to 1.0
  rootKey: number;    // 0 to 11
  scale: string;      // Scale Name
  isEnabled: boolean;
}

export class AutoTuneNode {
  private ctx: AudioContext;
  public input: GainNode;
  public output: GainNode;
  private worklet: AudioWorkletNode | null = null;
  private onStatusCallback: ((data: any) => void) | null = null;

  private params: AutoTuneParams = {
    speed: 0.1,
    humanize: 0.2,
    mix: 1.0,
    rootKey: 0,
    scale: 'CHROMATIC',
    isEnabled: true
  };

  constructor(ctx: AudioContext) {
    this.ctx = ctx;
    this.input = ctx.createGain();
    this.output = ctx.createGain();
    this.initWorklet();
  }

  private async initWorklet() {
    try {
      // Create a Blob from the inlined code
      const blob = new Blob([WORKLET_CODE], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);
      
      await this.ctx.audioWorklet.addModule(url);

      this.worklet = new AudioWorkletNode(this.ctx, 'auto-tune-processor', {
        numberOfInputs: 1,
        numberOfOutputs: 1,
        parameterData: {
          retuneSpeed: this.params.speed,
          amount: this.params.mix,
          rootKey: this.params.rootKey,
          scaleType: SCALES.indexOf(this.params.scale)
        }
      });

      this.worklet.port.onmessage = (event) => {
        if (this.onStatusCallback) {
          this.onStatusCallback(event.data);
        }
      };

      this.input.disconnect();
      this.input.connect(this.worklet);
      this.worklet.connect(this.output);
      
      this.applyParams(); 

    } catch (e) {
      console.error("[AutoTune] Worklet Load Error:", e);
      // Fallback: Bypass if fails
      this.input.connect(this.output);
    }
  }

  public updateParams(p: Partial<AutoTuneParams>) {
    this.params = { ...this.params, ...p };
    this.applyParams();
  }

  private applyParams() {
    if (!this.worklet) return;

    const { speed, mix, rootKey, scale, isEnabled } = this.params;
    const params = this.worklet.parameters;
    const now = this.ctx.currentTime;
    
    params.get('bypass')?.setValueAtTime(isEnabled ? 0 : 1, now);
    params.get('retuneSpeed')?.setTargetAtTime(speed, now, 0.01);
    params.get('amount')?.setTargetAtTime(mix, now, 0.01);
    params.get('rootKey')?.setValueAtTime(rootKey, now);
    const scaleIdx = SCALES.indexOf(scale);
    params.get('scaleType')?.setValueAtTime(scaleIdx >= 0 ? scaleIdx : 0, now);
  }

  public setStatusCallback(cb: (data: any) => void) {
    this.onStatusCallback = cb;
  }
}

interface AutoTuneUIProps {
  node: AutoTuneNode;
  initialParams: AutoTuneParams;
  onParamsChange?: (p: AutoTuneParams) => void;
}

export const AutoTuneUI: React.FC<AutoTuneUIProps> = ({ node, initialParams, onParamsChange }) => {
  const [params, setParams] = useState<AutoTuneParams>(initialParams);
  const [vizData, setVizData] = useState({ detectedFreq: 0, targetFreq: 0, correctionCents: 0 });
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const isDragging = useRef(false);
  const activeParam = useRef<keyof AutoTuneParams | null>(null);

  useEffect(() => {
    node.setStatusCallback((data) => {
      setVizData(data);
    });
    return () => node.setStatusCallback(() => {});
  }, [node]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d')!;
    let frameId: number;

    const draw = () => {
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.beginPath();
      ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h); 
      ctx.stroke();

      ctx.fillStyle = 'rgba(0, 242, 255, 0.05)';
      ctx.fillRect(w/2 - 20, 0, 40, h);

      if (vizData.detectedFreq > 50) {
        const offset = Math.max(-100, Math.min(100, vizData.correctionCents));
        const x = (w / 2) + (offset / 100) * (w / 2); 

        ctx.strokeStyle = '#00f2ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(w/2, h/2 - 20); ctx.lineTo(w/2, h/2 + 20);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x, h/2, 8, 0, Math.PI * 2);
        ctx.fillStyle = params.isEnabled ? '#ffffff' : '#555';
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(x, h/2);
        ctx.lineTo(w/2, h/2);
        ctx.strokeStyle = \`rgba(0, 242, 255, \${Math.abs(offset) / 100})\`;
        ctx.stroke();
      }

      frameId = requestAnimationFrame(draw);
    };
    draw();
    return () => cancelAnimationFrame(frameId);
  }, [vizData, params.isEnabled]);

  const handleMouseDown = (param: keyof AutoTuneParams, e: React.MouseEvent) => {
    e.preventDefault();
    isDragging.current = true;
    activeParam.current = param;
    document.body.style.cursor = 'ns-resize';
  };

  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (!isDragging.current || !activeParam.current) return;
    const delta = -e.movementY / 150;
    
    setParams(prev => {
      const currentVal = prev[activeParam.current!];
      if (typeof currentVal !== 'number') return prev;
      
      const newVal = Math.max(0, Math.min(1, currentVal + delta));
      const newParams = { ...prev, [activeParam.current!]: newVal };
      node.updateParams(newParams);
      if (onParamsChange) onParamsChange(newParams);
      return newParams;
    });
  }, [node, onParamsChange]);

  const handleMouseUp = useCallback(() => {
    isDragging.current = false;
    activeParam.current = null;
    document.body.style.cursor = 'default';
  }, []);

  useEffect(() => {
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [handleMouseMove, handleMouseUp]);

  const updateParam = (key: keyof AutoTuneParams, value: any) => {
    const newParams = { ...params, [key]: value };
    setParams(newParams);
    node.updateParams(newParams);
    if (onParamsChange) onParamsChange(newParams);
  };

  const getNoteName = (freq: number) => {
    if (freq <= 0) return '--';
    const midi = Math.round(69 + 12 * Math.log2(freq / 440));
    return NOTES[midi % 12] || '--';
  };

  return (
    <div className="w-[480px] bg-[#0c0d10] border border-white/10 rounded-[40px] p-10 shadow-2xl flex flex-col space-y-10 animate-in fade-in zoom-in duration-300 select-none">
      <div className="flex justify-between items-start">
        <div className="flex items-center space-x-5">
          <div className="w-14 h-14 rounded-2xl bg-cyan-500/10 flex items-center justify-center text-cyan-400 border border-cyan-500/20">
            <i className="fas fa-microphone-alt text-2xl"></i>
          </div>
          <div>
            <h2 className="text-xl font-black italic text-white uppercase tracking-tighter leading-none">Auto-Tune <span className="text-cyan-400">Pro</span></h2>
            <p className="text-[8px] font-black text-slate-500 uppercase tracking-widest mt-2">Real-Time DSP Worklet</p>
          </div>
        </div>
        <button 
          onClick={() => updateParam('isEnabled', !params.isEnabled)}
          className={\`w-12 h-12 rounded-full flex items-center justify-center transition-all border \${params.isEnabled ? 'bg-cyan-500 border-cyan-400 text-black shadow-lg shadow-cyan-500/40' : 'bg-white/5 border-white/10 text-slate-600 hover:text-white'}\`}
        >
          <i className="fas fa-power-off"></i>
        </button>
      </div>

      <div className="h-44 bg-black/60 rounded-[32px] border border-white/5 relative flex flex-col items-center justify-center overflow-hidden shadow-inner group">
        <canvas ref={canvasRef} width={400} height={176} className="absolute inset-0 opacity-60" />
        <div className="relative text-center z-10 pointer-events-none">
           <span className="block text-[9px] font-black text-cyan-500/50 uppercase tracking-[0.5em] mb-2">Correction Target</span>
           <span className="text-7xl font-black text-white font-mono tracking-tighter leading-none text-shadow-glow">
             {vizData.targetFreq > 0 ? getNoteName(vizData.targetFreq) : '--'}
           </span>
           <span className="block text-[10px] font-black text-slate-400 uppercase tracking-widest mt-2">
             In: {getNoteName(vizData.detectedFreq)}
           </span>
        </div>
      </div>

      <div className="grid grid-cols-2 gap-6 bg-white/[0.02] p-6 rounded-[24px] border border-white/5">
        <div className="space-y-3">
          <label className="text-[8px] font-black text-slate-500 uppercase tracking-widest ml-1">Key</label>
          <select 
            value={params.rootKey} 
            onChange={(e) => updateParam('rootKey', parseInt(e.target.value))}
            className="w-full bg-[#14161a] border border-white/10 rounded-xl p-3 text-[11px] font-black text-white hover:border-cyan-500/50 outline-none appearance-none cursor-pointer"
          >
            {NOTES.map((n, i) => <option key={n} value={i}>{n}</option>)}
          </select>
        </div>
        <div className="space-y-3">
          <label className="text-[8px] font-black text-slate-500 uppercase tracking-widest ml-1">Scale</label>
          <select 
            value={params.scale} 
            onChange={(e) => updateParam('scale', e.target.value as any)}
            className="w-full bg-[#14161a] border border-white/10 rounded-xl p-3 text-[11px] font-black text-white hover:border-cyan-500/50 outline-none appearance-none cursor-pointer"
          >
            {SCALES.map(s => <option key={s} value={s}>{s.replace('_', ' ').toUpperCase()}</option>)}
          </select>
        </div>
      </div>

      <div className="grid grid-cols-3 gap-8 pt-2">
        <TuneKnob label="Retune Speed" value={params.speed} onMouseDown={(e) => handleMouseDown('speed', e)} factor={100} suffix="%" inverseLabel={true} />
        <TuneKnob label="Humanize" value={params.humanize} onMouseDown={(e) => handleMouseDown('humanize', e)} factor={100} suffix="%" />
        <TuneKnob label="Amount" value={params.mix} onMouseDown={(e) => handleMouseDown('mix', e)} factor={100} suffix="%" />
      </div>
    </div>
  );
};

const TuneKnob: React.FC<{ label: string, value: number, onMouseDown: (e: React.MouseEvent) => void, factor: number, suffix: string, inverseLabel?: boolean }> = ({ label, value, onMouseDown, factor, suffix, inverseLabel }) => {
  const rotation = (value * 270) - 135;
  let displayValue = \`\${Math.round(value * factor)}\${suffix}\`;
  if (inverseLabel) {
      if (value < 0.1) displayValue = "ROBOT";
      else if (value > 0.9) displayValue = "NATURAL";
      else displayValue = \`\${Math.round((1-value) * 100)}ms\`; 
  }

  return (
    <div className="flex flex-col items-center space-y-3 group">
      <div 
        onMouseDown={onMouseDown} 
        className="w-16 h-16 rounded-full bg-[#14161a] border-2 border-white/10 flex items-center justify-center cursor-ns-resize hover:border-cyan-500/50 transition-all shadow-xl relative"
      >
        <div className="absolute inset-1.5 rounded-full border border-white/5 bg-black/40 shadow-inner" />
        <div 
          className="absolute top-1/2 left-1/2 w-1.5 h-6 -ml-0.75 -mt-6 origin-bottom rounded-full transition-transform duration-75" 
          style={{ transform: \`rotate(\${rotation}deg) translateY(2px)\`, backgroundColor: '#00f2ff', boxShadow: '0 0 10px #00f2ff' }} 
        />
        <div className="absolute inset-5 rounded-full bg-[#1c1f26] border border-white/5" />
      </div>
      <div className="text-center">
        <span className="block text-[8px] font-black text-slate-500 uppercase tracking-widest mb-1.5">{label}</span>
        <div className="bg-black/60 px-3 py-1 rounded-lg border border-white/5 min-w-[55px]">
          <span className="text-[10px] font-mono font-bold text-cyan-400">{displayValue}</span>
        </div>
      </div>
    </div>
  );
};` },
{ path: "plugins/EQPlugin.tsx", content: `
import React, { useEffect, useRef, useState, useMemo, useCallback } from 'react';

/**
 * MODULE FX_01 : EQ PARAMÉTRIQUE PRO (11 BANDES)
 * ---------------------------------------------
 * DSP: 11 BiquadFilterNodes en série.
 * Contrôles : Clic+Drag (Freq/Gain), Molette/Shift+Drag (Q).
 * Visualisation : Courbe de transfert cumulée + Analyseur FFT.
 */

export type FilterType = 'highpass' | 'lowshelf' | 'peaking' | 'highshelf' | 'lowpass' | 'notch';
export interface EQBand { 
  id: number; 
  type: FilterType; 
  frequency: number; 
  gain: number; 
  q: number; 
  enabled: boolean; 
  color: string; 
}
export interface EQParams { 
  bands: EQBand[]; 
  masterGain: number; 
  isEnabled: boolean; 
}

const MIN_FREQ = 20; 
const MAX_FREQ = 20000; 
const MIN_GAIN = -24; 
const MAX_GAIN = 24;

export class EQNode {
  private ctx: AudioContext; 
  public input: GainNode; 
  public output: GainNode; 
  public analyzer: AnalyserNode;
  private filters: BiquadFilterNode[] = []; 
  private params: EQParams;
  private lastActiveStates: string = '';

  constructor(ctx: AudioContext, initialParams: EQParams) {
    this.ctx = ctx; 
    this.params = initialParams; 
    this.input = ctx.createGain(); 
    this.output = ctx.createGain();
    this.analyzer = ctx.createAnalyser(); 
    this.analyzer.fftSize = 2048; 
    this.setupChain();
  }

  private setupChain() {
    this.input.disconnect(); 
    this.filters.forEach(f => { try { f.disconnect(); } catch(e) {} }); 
    this.filters = [];

    let lastNode: AudioNode = this.input;
    
    this.params.bands.forEach(band => {
      const filter = this.ctx.createBiquadFilter();
      filter.type = band.type; 
      filter.frequency.value = band.frequency; 
      filter.gain.value = band.gain; 
      filter.Q.value = band.q;
      
      if (band.enabled && this.params.isEnabled) { 
        lastNode.connect(filter); 
        lastNode = filter; 
      }
      this.filters.push(filter);
    });

    lastNode.connect(this.analyzer); 
    this.analyzer.connect(this.output);
  }

  public updateParams(newParams: Partial<EQParams>) {
    const oldEnabled = this.params.isEnabled;
    this.params = { ...this.params, ...newParams };
    
    this.params.bands.forEach((band, i) => {
      const f = this.filters[i];
      if (f) {
        f.type = band.type; 
        const time = this.ctx.currentTime + 0.02;
        f.frequency.setTargetAtTime(band.frequency, time, 0.015);
        f.gain.setTargetAtTime(band.gain, time, 0.015);
        f.Q.setTargetAtTime(band.q, time, 0.015);
      }
    });

    const activeStates = this.params.bands.map(b => b.enabled).join() + this.params.isEnabled;
    if (this.lastActiveStates !== activeStates) { 
      this.setupChain(); 
      this.lastActiveStates = activeStates; 
    }
  }

  public getFrequencyResponse(freqs: Float32Array): Float32Array {
    const totalMag = new Float32Array(freqs.length).fill(1.0);
    const magResponse = new Float32Array(freqs.length);
    const phaseResponse = new Float32Array(freqs.length);
    
    this.filters.forEach((filter, i) => {
      if (this.params.bands[i].enabled && this.params.isEnabled) {
        filter.getFrequencyResponse(freqs, magResponse, phaseResponse);
        for (let j = 0; j < freqs.length; j++) {
          totalMag[j] *= magResponse[j];
        }
      }
    });
    return totalMag;
  }
}

const EQKnob: React.FC<{ 
  label: string, value: number, min: number, max: number, onChange: (v: number) => void, 
  suffix: string, color: string, log?: boolean, disabled?: boolean, precision?: number 
}> = ({ label, value, min, max, onChange, suffix, color, log, disabled, precision = 0 }) => {
  const norm = log ? (Math.log10(value / min) / Math.log10(max / min)) : (value - min) / (max - min);
  
  const handleMouseDown = (e: React.MouseEvent) => {
    e.preventDefault();
    const startY = e.clientY;
    const startNorm = norm;
    const onMouseMove = (m: MouseEvent) => {
      const delta = (startY - m.clientY) / 200;
      const newNorm = Math.max(0, Math.min(1, startNorm + delta));
      const val = log ? min * Math.pow(max / min, newNorm) : min + newNorm * (max - min);
      onChange(val);
    };
    const onMouseUp = () => {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    };
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
  };

  const rotation = (norm * 270) - 135;
  return (
    <div className={\`flex flex-col items-center space-y-2 select-none \${disabled ? 'opacity-20 grayscale' : ''}\`}>
      <div onMouseDown={handleMouseDown} className="relative w-12 h-12 rounded-full bg-[#14161a] border border-white/10 flex items-center justify-center cursor-ns-resize shadow-xl hover:border-white/30 transition-all">
        <div className="absolute inset-1 rounded-full border border-white/5 bg-black/40 shadow-inner" />
        <div 
          className="absolute top-1/2 left-1/2 w-1 h-5 -ml-0.5 -mt-5 origin-bottom rounded-full transition-transform duration-75" 
          style={{ backgroundColor: color, boxShadow: \`0 0 8px \${color}\`, transform: \`rotate(\${rotation}deg) translateY(2px)\` }} 
        />
        <div className="absolute inset-4 rounded-full bg-[#1c1f26] border border-white/5" />
      </div>
      <div className="text-center">
        <span className="block text-[6px] font-black text-slate-500 uppercase tracking-widest mb-1">{label}</span>
        <div className="bg-black/60 px-1.5 py-0.5 rounded border border-white/5 min-w-[45px]">
          <span className="text-[8px] font-mono font-bold text-white">{value.toFixed(precision)}{suffix}</span>
        </div>
      </div>
    </div>
  );
};

export const EQPluginUI: React.FC<{ node: EQNode, initialParams: EQParams }> = ({ node, initialParams }) => {
  const [params, setParams] = useState(initialParams);
  const [selectedBandIdx, setSelectedBandIdx] = useState(0);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  const freqToX = (f: number, w: number) => (Math.log10(f / MIN_FREQ) / Math.log10(MAX_FREQ / MIN_FREQ)) * w;
  const xToFreq = (x: number, w: number) => MIN_FREQ * Math.pow(MAX_FREQ / MIN_FREQ, x / w);
  const gainToY = (g: number, h: number) => (h / 2) - (g * (h / (MAX_GAIN - MIN_GAIN)) * 1.5);
  
  const frequencies = useMemo(() => {
    const f = new Float32Array(512);
    for (let i = 0; i < 512; i++) f[i] = MIN_FREQ * Math.pow(MAX_FREQ / MIN_FREQ, i / 511);
    return f;
  }, []);

  const updateBand = useCallback((idx: number, updates: Partial<EQBand>) => {
    setParams(prev => {
      const newBands = [...prev.bands]; 
      newBands[idx] = { ...newBands[idx], ...updates };
      const newParams = { ...prev, bands: newBands }; 
      node.updateParams(newParams); 
      return newParams;
    });
  }, [node]);

  const handleGraphMouseDown = (e: React.MouseEvent, idx: number) => {
    e.preventDefault(); 
    setSelectedBandIdx(idx);
    const startX = e.clientX; 
    const startY = e.clientY;
    const startFreq = params.bands[idx].frequency; 
    const startGain = params.bands[idx].gain;
    const rect = canvasRef.current?.getBoundingClientRect(); 
    if (!rect) return;

    const onMouseMove = (m: MouseEvent) => {
      const dx = m.clientX - startX; 
      const dy = startY - m.clientY;
      const curX = freqToX(startFreq, rect.width) + dx;
      const newFreq = Math.max(MIN_FREQ, Math.min(MAX_FREQ, xToFreq(Math.max(0, Math.min(rect.width, curX)), rect.width)));
      
      let newGain = startGain + (dy / (rect.height / 2)) * MAX_GAIN;
      if (params.bands[idx].type.includes('pass')) newGain = 0;
      else newGain = Math.max(MIN_GAIN, Math.min(MAX_GAIN, newGain));
      
      updateBand(idx, { frequency: newFreq, gain: newGain });
    };

    const onMouseUp = () => {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
      document.body.style.cursor = 'default';
    };

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    document.body.style.cursor = 'grabbing';
  };

  const handleWheel = (e: React.WheelEvent) => {
    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    const currentQ = params.bands[selectedBandIdx].q;
    const newQ = Math.max(0.1, Math.min(10, currentQ + delta));
    updateBand(selectedBandIdx, { q: newQ });
  };

  useEffect(() => {
    const canvas = canvasRef.current; 
    if (!canvas) return;
    const ctx = canvas.getContext('2d')!; 
    let frame: number;

    const draw = () => {
      const w = canvas.width; 
      const h = canvas.height; 
      ctx.clearRect(0, 0, w, h);

      // Grid
      ctx.strokeStyle = 'rgba(255,255,255,0.05)'; 
      ctx.lineWidth = 1;
      [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000].forEach(f => { 
        const x = freqToX(f, w); 
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); 
      });
      [12, 6, 0, -6, -12].forEach(g => {
        const y = gainToY(g, h);
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
      });

      // FFT Spectrum
      const spectrum = new Uint8Array(node.analyzer.frequencyBinCount); 
      node.analyzer.getByteFrequencyData(spectrum);
      ctx.fillStyle = 'rgba(0, 242, 255, 0.08)';
      for (let i = 0; i < w; i++) {
        const f = xToFreq(i, w); 
        const bin = Math.floor(f * node.analyzer.frequencyBinCount / (44100 / 2));
        const val = (spectrum[bin] / 255) * h * 0.6; 
        ctx.fillRect(i, h - val, 1, val);
      }

      // Global Response Curve
      const response = node.getFrequencyResponse(frequencies); 
      ctx.beginPath(); 
      ctx.strokeStyle = '#fff'; 
      ctx.lineWidth = 3;
      ctx.shadowBlur = 15;
      ctx.shadowColor = 'rgba(255,255,255,0.2)';
      
      response.forEach((mag, i) => {
        const x = (i / (frequencies.length - 1)) * w; 
        const db = 20 * Math.log10(Math.max(mag, 0.0001));
        const y = gainToY(db, h); 
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }); 
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Band Handles
      params.bands.forEach((band, idx) => {
        const x = freqToX(band.frequency, w); 
        const y = band.type.includes('pass') ? h / 2 : gainToY(band.gain, h);
        
        ctx.fillStyle = band.enabled ? band.color : '#333'; 
        ctx.beginPath(); 
        ctx.arc(x, y, idx === selectedBandIdx ? 8 : 5, 0, Math.PI * 2); 
        ctx.fill();
        
        if (idx === selectedBandIdx) { 
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke(); 
          // Band width visualization
          ctx.strokeStyle = \`\${band.color}44\`;
          ctx.lineWidth = 1;
          const bw = (w / band.q) * 0.1;
          ctx.beginPath(); ctx.moveTo(x - bw, y); ctx.lineTo(x + bw, y); ctx.stroke();
        }
      }); 
      frame = requestAnimationFrame(draw);
    }; 
    draw(); 
    return () => cancelAnimationFrame(frame);
  }, [node, frequencies, params, selectedBandIdx]);

  const currentBand = params.bands[selectedBandIdx];
  
  return (
    <div className="w-[850px] bg-[#0c0d10] border border-white/10 rounded-[40px] overflow-hidden shadow-2xl flex flex-col select-none animate-in fade-in zoom-in duration-300">
      {/* Header with power toggle */}
      <div className="p-8 border-b border-white/5 flex justify-between items-center bg-white/[0.02]">
        <div className="flex items-center space-x-6">
          <div className="w-14 h-14 rounded-2xl bg-cyan-500/10 flex items-center justify-center text-cyan-400 border border-cyan-500/20 shadow-lg shadow-cyan-500/5">
            <i className="fas fa-wave-square text-2xl"></i>
          </div>
          <div>
            <h2 className="text-2xl font-black italic text-white uppercase tracking-tighter leading-none">Pro-Q <span className="text-cyan-400">Nova</span> <span className="text-[10px] ml-2 font-normal text-slate-500">11-BAND</span></h2>
            <p className="text-[9px] font-black text-slate-500 uppercase tracking-widest mt-2">Surgical Mastering Equalizer</p>
          </div>
        </div>
        
        <div className="flex items-center space-x-4">
           <div className="flex bg-black/40 rounded-xl p-1 border border-white/5">
            {params.bands.map((b, i) => (
              <button 
                key={i} 
                onClick={() => setSelectedBandIdx(i)} 
                className={\`w-8 h-8 rounded-lg text-[9px] font-black transition-all border \${selectedBandIdx === i ? 'bg-white text-black border-white' : 'bg-transparent text-slate-600 border-transparent hover:text-slate-400'}\`}
                style={{ color: selectedBandIdx === i ? '#000' : b.color }}
              >
                {i + 1}
              </button>
            ))}
          </div>
          <button 
            onClick={() => { const newState = !params.isEnabled; setParams({...params, isEnabled: newState}); node.updateParams({isEnabled: newState}); }}
            className={\`w-12 h-12 rounded-full border transition-all flex items-center justify-center \${params.isEnabled ? 'bg-cyan-500 border-cyan-400 text-black shadow-lg shadow-cyan-500/40' : 'bg-white/5 border-white/10 text-slate-600'}\`}
          >
            <i className="fas fa-power-off"></i>
          </button>
        </div>
      </div>

      {/* Main Canvas Area */}
      <div className="relative h-[320px] bg-black/40 cursor-crosshair border-b border-white/5 overflow-hidden" onWheel={handleWheel}>
        <div className="absolute inset-0 pointer-events-none bg-[radial-gradient(circle_at_center,rgba(0,242,255,0.03),transparent)]" />
        <canvas 
          ref={canvasRef} 
          width={850} 
          height={320} 
          className="w-full h-full" 
          onMouseDown={(e) => {
            const rect = canvasRef.current?.getBoundingClientRect(); 
            if (!rect) return;
            const x = e.clientX - rect.left; 
            const y = e.clientY - rect.top;
            let closestIdx = -1; 
            let minDist = 40;
            
            params.bands.forEach((b, i) => {
              const bx = freqToX(b.frequency, rect.width); 
              const by = b.type.includes('pass') ? rect.height / 2 : gainToY(b.gain, rect.height);
              const dist = Math.sqrt((x - bx) ** 2 + (y - by) ** 2);
              if (dist < minDist) { minDist = dist; closestIdx = i; }
            });
            if (closestIdx !== -1) handleGraphMouseDown(e, closestIdx);
          }} 
        />
        <div className="absolute bottom-4 right-6 text-[8px] font-black text-slate-700 uppercase tracking-[0.3em]">Bilateral Frequency Map</div>
      </div>

      {/* Control Panel */}
      <div className="p-10 bg-white/[0.01] flex flex-col space-y-10">
        <div className="flex items-center justify-between">
           <div className="flex items-center space-x-10">
              <div className="space-y-4">
                <label className="text-[9px] font-black text-slate-600 uppercase tracking-widest ml-1">Band Mode</label>
                <div className="grid grid-cols-3 gap-2">
                  {(['highpass', 'lowshelf', 'peaking', 'highshelf', 'lowpass', 'notch'] as FilterType[]).map(t => (
                    <button 
                      key={t} 
                      onClick={() => updateBand(selectedBandIdx, { type: t, gain: (t.includes('pass') || t === 'notch') ? 0 : currentBand.gain })} 
                      className={\`px-4 py-2 rounded-xl text-[8px] font-black uppercase border transition-all \${currentBand.type === t ? 'bg-cyan-500 text-black border-cyan-500 shadow-lg shadow-cyan-500/20' : 'bg-white/5 border-white/10 text-slate-600 hover:text-white'}\`}
                    >
                      {t.replace('pass', '').replace('shelf', '')}
                    </button>
                  ))}
                </div>
              </div>

              <div className="h-16 w-px bg-white/5 self-end mb-1" />

              <div className="flex space-x-8">
                <EQKnob label="Frequency" value={currentBand.frequency} min={MIN_FREQ} max={MAX_FREQ} log suffix="Hz" onChange={v => updateBand(selectedBandIdx, { frequency: v })} color={currentBand.color} />
                <EQKnob label="Gain" value={currentBand.gain} min={MIN_GAIN} max={MAX_GAIN} suffix="dB" onChange={v => updateBand(selectedBandIdx, { gain: v })} color={currentBand.color} disabled={currentBand.type.includes('pass') || currentBand.type === 'notch'} precision={1} />
                <EQKnob label="Q Factor" value={currentBand.q} min={0.1} max={10} suffix="" onChange={v => updateBand(selectedBandIdx, { q: v })} color={currentBand.color} precision={2} />
              </div>
           </div>

           <div className="flex flex-col items-end space-y-4">
              <button 
                onClick={() => updateBand(selectedBandIdx, { enabled: !currentBand.enabled })}
                className={\`h-10 px-8 rounded-xl text-[9px] font-black uppercase tracking-widest border transition-all \${currentBand.enabled ? 'bg-white/5 border-white/20 text-white' : 'bg-red-500/20 border-red-500/40 text-red-500'}\`}
              >
                {currentBand.enabled ? 'Band Active' : 'Band Muted'}
              </button>
              <div className="flex items-center space-x-2">
                 <div className="w-2 h-2 rounded-full bg-cyan-500 shadow-[0_0_8px_cyan]" />
                 <span className="text-[7px] font-black text-slate-700 uppercase tracking-[0.4em]">Surgical Precision Enabled</span>
              </div>
           </div>
        </div>
      </div>
    </div>
  );
};` },
{ path: "plugins/ReverbPlugin.tsx", content: `
import React, { useEffect, useRef, useState, useCallback } from 'react';

/**
 * MODULE FX_05 : PROFESSIONAL REVERB (VELVET NOISE ENGINE)
 * -------------------------------------------------
 * Logic: Generates a high-density "Velvet Noise" Impulse Response.
 * Improvements: Smother tails, distinct Early Reflections vs Late Reverb, stereo decorrelation.
 */

export type ReverbMode = 'ROOM' | 'HALL' | 'PLATE' | 'CATHEDRAL';

export interface ReverbParams {
  decay: number;      // 0.1 to 10s
  preDelay: number;   // 0 to 200ms
  damping: number;    // 100Hz to 20000Hz
  mix: number;        // 0 to 1
  size: number;       // 0 to 1 (Diffusion/Spread)
  mode: ReverbMode;
  isEnabled: boolean;
  name?: string;
}

export const REVERB_PRESETS = [
  { name: "Studio Booth", decay: 0.4, preDelay: 0.010, damping: 6000, size: 0.2, mix: 0.15, mode: 'ROOM' as ReverbMode },
  { name: "Modern Vocal Plate", decay: 1.4, preDelay: 0.025, damping: 12000, size: 0.6, mix: 0.20, mode: 'PLATE' as ReverbMode },
  { name: "Small Warm Room", decay: 0.8, preDelay: 0.015, damping: 4000, size: 0.3, mix: 0.18, mode: 'ROOM' as ReverbMode },
  { name: "Large Hall", decay: 2.8, preDelay: 0.040, damping: 8000, size: 0.9, mix: 0.25, mode: 'HALL' as ReverbMode },
  { name: "Cathedral", decay: 5.0, preDelay: 0.060, damping: 5000, size: 1.0, mix: 0.35, mode: 'CATHEDRAL' as ReverbMode },
  { name: "Slapback Space", decay: 0.3, preDelay: 0.080, damping: 10000, size: 0.1, mix: 0.22, mode: 'ROOM' as ReverbMode },
  { name: "Dark Ambience", decay: 3.5, preDelay: 0.030, damping: 2000, size: 0.8, mix: 0.20, mode: 'HALL' as ReverbMode },
  { name: "Vocal Cloud", decay: 4.5, preDelay: 0.020, damping: 16000, size: 0.95, mix: 0.30, mode: 'CATHEDRAL' as ReverbMode },
  { name: "Bright Chamber", decay: 1.8, preDelay: 0.035, damping: 14000, size: 0.5, mix: 0.25, mode: 'HALL' as ReverbMode },
  { name: "In Your Face", decay: 0.2, preDelay: 0.005, damping: 18000, size: 0.05, mix: 0.10, mode: 'ROOM' as ReverbMode },
];

export class ReverbNode {
  private ctx: AudioContext;
  public input: GainNode;
  public output: GainNode;
  
  private preDelayNode: DelayNode;
  private convolver: ConvolverNode;
  private dampingFilter: BiquadFilterNode;
  private inputFilter: BiquadFilterNode; // Highpass to clear mud
  private wetGain: GainNode;
  private dryGain: GainNode;
  
  private params: ReverbParams = {
    decay: 2.5,
    preDelay: 0.02,
    damping: 12000,
    mix: 0.3,
    size: 0.7,
    mode: 'HALL',
    isEnabled: true
  };

  constructor(ctx: AudioContext) {
    this.ctx = ctx;
    this.input = ctx.createGain();
    this.output = ctx.createGain();
    
    this.preDelayNode = ctx.createDelay(1.0);
    this.convolver = ctx.createConvolver();
    
    this.dampingFilter = ctx.createBiquadFilter();
    this.dampingFilter.type = 'lowpass';
    
    this.inputFilter = ctx.createBiquadFilter();
    this.inputFilter.type = 'highpass';
    this.inputFilter.frequency.value = 150; // Clean up low end before reverb

    this.wetGain = ctx.createGain();
    this.dryGain = ctx.createGain();

    this.setupChain();
    this.updateImpulseResponse();
  }

  private setupChain() {
    this.input.disconnect();
    
    // Dry Path
    this.input.connect(this.dryGain);
    this.dryGain.connect(this.output);
    
    // Wet Path
    this.input.connect(this.inputFilter);
    this.inputFilter.connect(this.preDelayNode);
    this.preDelayNode.connect(this.convolver);
    this.convolver.connect(this.dampingFilter);
    this.dampingFilter.connect(this.wetGain);
    this.wetGain.connect(this.output);
    
    this.updateRouting();
  }

  private updateRouting() {
    const now = this.ctx.currentTime;
    if (this.params.isEnabled) {
      this.dryGain.gain.setTargetAtTime(1 - (this.params.mix * 0.5), now, 0.02);
      this.wetGain.gain.setTargetAtTime(this.params.mix, now, 0.02);
    } else {
      this.dryGain.gain.setTargetAtTime(1, now, 0.02);
      this.wetGain.gain.setTargetAtTime(0, now, 0.02);
    }
  }

  public updateParams(p: Partial<ReverbParams>) {
    const oldDecay = this.params.decay;
    const oldSize = this.params.size;
    const oldMode = this.params.mode;

    this.params = { ...this.params, ...p };
    
    const now = this.ctx.currentTime;
    this.preDelayNode.delayTime.setTargetAtTime(this.params.preDelay, now, 0.02);
    this.dampingFilter.frequency.setTargetAtTime(this.params.damping, now, 0.02);
    
    this.updateRouting();

    // Regenerate IR only if structural parameters change
    if (this.params.decay !== oldDecay || this.params.size !== oldSize || this.params.mode !== oldMode) {
      this.updateImpulseResponse();
    }
  }

  /**
   * Generates a "Velvet Noise" Impulse Response
   * This sounds much smoother than standard white noise.
   */
  private updateImpulseResponse() {
    const sampleRate = this.ctx.sampleRate;
    const duration = this.params.decay;
    const length = sampleRate * duration;
    const buffer = this.ctx.createBuffer(2, length, sampleRate);
    
    const left = buffer.getChannelData(0);
    const right = buffer.getChannelData(1);

    // Mode-specific constants
    let density = this.params.size * 2000; // Impulses per second
    if (this.params.mode === 'PLATE') density *= 2; // Plates are dense
    if (this.params.mode === 'ROOM') density *= 0.5; // Rooms are sparse

    const decayConstant = this.params.mode === 'CATHEDRAL' ? 4 : (this.params.mode === 'PLATE' ? 6 : 8);

    for (let c = 0; c < 2; c++) {
      const channel = c === 0 ? left : right;
      let k = 0;
      while (k < length) {
        // Random spacing for Velvet Noise (prevents metallic ringing)
        const step = Math.round(sampleRate / density * (0.5 + Math.random())); 
        if (k + step >= length) break;
        k += step;

        const time = k / sampleRate;
        // Exponential decay envelope
        const envelope = Math.pow(1 - time / duration, decayConstant);
        
        // Random sign pulse
        const sign = Math.random() > 0.5 ? 1 : -1;
        
        // Stereo spread decoration
        const spread = c === 0 ? 1 : (0.9 + Math.random() * 0.2);

        channel[k] = sign * envelope * spread * 0.8;
      }
    }
    
    this.convolver.buffer = buffer;
  }

  public getParams() { return this.params; }
}

/**
 * REVERB UI COMPONENT
 */
export const ProfessionalReverbUI: React.FC<{ node: ReverbNode, initialParams: ReverbParams, onParamsChange?: (p: ReverbParams) => void }> = ({ node, initialParams, onParamsChange }) => {
  const [params, setParams] = useState(initialParams);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  const handleParamChange = (key: keyof ReverbParams, value: any) => {
    const newParams = { ...params, [key]: value };
    setParams(newParams);
    node.updateParams(newParams);
    if (onParamsChange) onParamsChange(newParams);
  };

  const loadPreset = (index: number) => {
    const preset = REVERB_PRESETS[index];
    const newParams = { ...params, ...preset };
    setParams(newParams);
    node.updateParams(newParams);
    if (onParamsChange) onParamsChange(newParams);
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d')!;
    const w = canvas.width;
    const h = canvas.height;

    const draw = () => {
      ctx.clearRect(0, 0, w, h);
      
      // Background Grid
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.beginPath();
      for(let x=0; x<w; x+=30) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
      ctx.stroke();

      // Main Decay Curve
      ctx.beginPath();
      ctx.strokeStyle = '#6366f1';
      ctx.lineWidth = 2;
      ctx.moveTo(0, h - 20);
      
      const duration = params.decay;
      const displayTime = 6; // Max 6s on graph
      
      for(let x=0; x<w; x++) {
        const t = (x / w) * displayTime;
        if (t > duration) break;
        
        // Inverse exponential for visualization
        const decayConst = 5;
        const envelope = Math.pow(1 - t / duration, 4);
        
        // Add "Velvet" texture to visualization
        const noise = (Math.random() * 0.15 * envelope);
        
        const y = (h - 20) - ((envelope + noise) * (h - 40));
        ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Pre-delay marker
      const preDelayX = (params.preDelay / displayTime) * w;
      ctx.strokeStyle = '#ef4444';
      ctx.setLineDash([3, 3]);
      ctx.beginPath(); 
      ctx.moveTo(preDelayX, 0); 
      ctx.lineTo(preDelayX, h); 
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Glow
      ctx.shadowBlur = 15;
      ctx.shadowColor = '#6366f1';
      ctx.stroke();
      ctx.shadowBlur = 0;

      requestAnimationFrame(draw);
    };
    const animId = requestAnimationFrame(draw);
    return () => cancelAnimationFrame(animId);
  }, [params.decay, params.preDelay]);

  return (
    <div className="w-[600px] bg-[#0c0d10] border border-white/10 rounded-[40px] p-10 shadow-2xl flex flex-col space-y-10 animate-in fade-in zoom-in duration-300 select-none">
      <div className="flex justify-between items-center">
        <div className="flex items-center space-x-5">
          <div className="w-14 h-14 rounded-2xl bg-indigo-500/10 flex items-center justify-center text-indigo-400 border border-indigo-500/20">
            <i className="fas fa-mountain-sun text-2xl"></i>
          </div>
          <div>
            <h2 className="text-2xl font-black italic text-white uppercase tracking-tighter leading-none">Spatial <span className="text-indigo-400">Verb</span></h2>
            <p className="text-[9px] font-black text-slate-500 uppercase tracking-widest mt-2">Velvet Noise Engine v2.0</p>
          </div>
        </div>
        
        <div className="flex flex-col space-y-3 items-end">
           <div className="flex bg-black/40 p-1 rounded-2xl border border-white/5">
            {(['ROOM', 'HALL', 'PLATE', 'CATHEDRAL'] as ReverbMode[]).map(m => (
              <button 
                key={m}
                onClick={() => handleParamChange('mode', m)}
                className={\`px-4 py